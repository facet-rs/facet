//! ⚠️  AUTO-GENERATED by benchmark-generator ⚠️
//!
//! ❌ DO NOT EDIT THIS FILE DIRECTLY
//! ✅ Instead, edit: facet-perf-shootout/benches/postcard.kdl
//!
//! Shared benchmark operations for the {} format.
//! These inline functions are called by both divan and gungraun benchmarks.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::explicit_auto_deref)]

use std::hint::black_box;
use std::sync::LazyLock;

use ::postcard as postcard_crate;

pub use crate::postcard_types::*;

pub mod vec_bool_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<bool>> =
        LazyLock::new(|| (0..1000).map(|i| i % 3 != 0).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<bool> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<bool> {
        postcard_crate::from_bytes::<Vec<bool>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<bool> {
        facet_postcard::from_slice::<Vec<bool>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u8_empty {
    use super::*;

    pub static DATA: LazyLock<Vec<u8>> = LazyLock::new(|| Vec::new());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u8> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u8> {
        postcard_crate::from_bytes::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u8> {
        facet_postcard::from_slice::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u8_16 {
    use super::*;

    pub static DATA: LazyLock<Vec<u8>> = LazyLock::new(|| (0..16u8).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u8> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u8> {
        postcard_crate::from_bytes::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u8> {
        facet_postcard::from_slice::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u8_256 {
    use super::*;

    pub static DATA: LazyLock<Vec<u8>> = LazyLock::new(|| (0u8..=255).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u8> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u8> {
        postcard_crate::from_bytes::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u8> {
        facet_postcard::from_slice::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u8_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<u8>> =
        LazyLock::new(|| (0..1000).map(|i| (i % 256) as u8).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u8> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u8> {
        postcard_crate::from_bytes::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u8> {
        facet_postcard::from_slice::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u8_64k {
    use super::*;

    pub static DATA: LazyLock<Vec<u8>> =
        LazyLock::new(|| (0..65536).map(|i| (i % 256) as u8).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u8> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u8> {
        postcard_crate::from_bytes::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u8> {
        facet_postcard::from_slice::<Vec<u8>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u32_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<u32>> = LazyLock::new(|| {
        (0..1000)
            .map(|i| match i % 4 {
                0 => i as u32,
                1 => (i as u32) * 100,
                2 => (i as u32) * 10000,
                _ => (i as u32) * 1000000,
            })
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u32> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u32> {
        postcard_crate::from_bytes::<Vec<u32>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u32> {
        facet_postcard::from_slice::<Vec<u32>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u64_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<u64>> = LazyLock::new(|| {
        (0..1000)
            .map(|i| match i % 5 {
                0 => i as u64,
                1 => (i as u64) * 1000,
                2 => (i as u64) * 1000000,
                3 => (i as u64) * 1000000000,
                _ => u64::MAX / (i as u64 + 1),
            })
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u64> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u64> {
        postcard_crate::from_bytes::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u64> {
        facet_postcard::from_slice::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u64_small {
    use super::*;

    pub static DATA: LazyLock<Vec<u64>> = LazyLock::new(|| (0..10).map(|i| i * 12345u64).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u64> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u64> {
        postcard_crate::from_bytes::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u64> {
        facet_postcard::from_slice::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_u64_large {
    use super::*;

    pub static DATA: LazyLock<Vec<u64>> =
        LazyLock::new(|| (0..10000).map(|i| i * 12345u64).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<u64> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<u64> {
        postcard_crate::from_bytes::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<u64> {
        facet_postcard::from_slice::<Vec<u64>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_i32_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<i32>> = LazyLock::new(|| {
        (0..1000i32)
            .map(|i| {
                let base = i * 100;
                if i % 2 == 0 { base } else { -base }
            })
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<i32> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<i32> {
        postcard_crate::from_bytes::<Vec<i32>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<i32> {
        facet_postcard::from_slice::<Vec<i32>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_i64_1k {
    use super::*;

    pub static DATA: LazyLock<Vec<i64>> = LazyLock::new(|| {
        (0..1000i64)
            .map(|i| {
                let base = i * 1000000;
                if i % 2 == 0 { base } else { -base }
            })
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<i64> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<i64> {
        postcard_crate::from_bytes::<Vec<i64>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<i64> {
        facet_postcard::from_slice::<Vec<i64>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod simple_struct {
    use super::*;

    pub static DATA: LazyLock<SimpleStruct> = LazyLock::new(|| SimpleStruct {
        id: 42,
        name: "test".to_string(),
        active: true,
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static SimpleStruct {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> SimpleStruct {
        postcard_crate::from_bytes::<SimpleStruct>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> SimpleStruct {
        facet_postcard::from_slice::<SimpleStruct>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod nested_struct {
    use super::*;

    pub static DATA: LazyLock<NestedStruct> = LazyLock::new(|| NestedStruct {
        id: 42,
        inner: NestedInner {
            x: 10,
            y: 20,
            label: "inner".to_string(),
        },
        enabled: true,
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static NestedStruct {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> NestedStruct {
        postcard_crate::from_bytes::<NestedStruct>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> NestedStruct {
        facet_postcard::from_slice::<NestedStruct>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod wide_struct {
    use super::*;

    pub static DATA: LazyLock<WideStruct> = LazyLock::new(|| WideStruct {
        field_00: 0,
        field_01: 1,
        field_02: 2,
        field_03: 3,
        field_04: 4,
        field_05: 5,
        field_06: 6,
        field_07: 7,
        field_08: 8,
        field_09: 9,
        field_10: "s10".to_string(),
        field_11: "s11".to_string(),
        field_12: "s12".to_string(),
        field_13: "s13".to_string(),
        field_14: "s14".to_string(),
        field_15: true,
        field_16: false,
        field_17: true,
        field_18: false,
        field_19: true,
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static WideStruct {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> WideStruct {
        postcard_crate::from_bytes::<WideStruct>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> WideStruct {
        facet_postcard::from_slice::<WideStruct>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_simple_struct {
    use super::*;

    pub static DATA: LazyLock<Vec<SimpleStruct>> = LazyLock::new(|| {
        (0..100)
            .map(|i| SimpleStruct {
                id: i,
                name: format!("name_{}", i),
                active: i % 2 == 0,
            })
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<SimpleStruct> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<SimpleStruct> {
        postcard_crate::from_bytes::<Vec<SimpleStruct>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<SimpleStruct> {
        facet_postcard::from_slice::<Vec<SimpleStruct>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_string_short {
    use super::*;

    pub static DATA: LazyLock<Vec<String>> =
        LazyLock::new(|| (0..1000).map(|i| format!("str_{:06}", i)).collect());
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<String> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<String> {
        postcard_crate::from_bytes::<Vec<String>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<String> {
        facet_postcard::from_slice::<Vec<String>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}

pub mod vec_string_long {
    use super::*;

    pub static DATA: LazyLock<Vec<String>> = LazyLock::new(|| {
        (0..100)
            .map(|i| "x".repeat(1000) + format!("_{}", i).as_str())
            .collect()
    });
    pub static ENCODED: LazyLock<Vec<u8>> =
        LazyLock::new(|| postcard_crate::to_allocvec(&*DATA).unwrap());

    #[inline(always)]
    pub fn encoded_bytes() -> &'static [u8] {
        &*ENCODED
    }

    #[inline(always)]
    pub fn data() -> &'static Vec<String> {
        &*DATA
    }

    // ===== DESERIALIZE =====

    #[inline(always)]
    pub fn postcard_deserialize() -> Vec<String> {
        postcard_crate::from_bytes::<Vec<String>>(black_box(encoded_bytes())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_deserialize() -> Vec<String> {
        facet_postcard::from_slice::<Vec<String>>(black_box(encoded_bytes())).unwrap()
    }

    // ===== SERIALIZE =====

    #[inline(always)]
    pub fn postcard_serialize() -> Vec<u8> {
        postcard_crate::to_allocvec(black_box(data())).unwrap()
    }

    #[inline(always)]
    pub fn facet_postcard_t0_serialize() -> Vec<u8> {
        facet_postcard::to_vec(black_box(data())).unwrap()
    }
}
