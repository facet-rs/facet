//! Example extension crate demonstrating the attribute grammar system.
//!
//! This is the "orm" equivalent - an extension that defines its own attributes.

// NOTE: For Phase 1, we hand-write what `define_attr_grammar!` would generate.
// This validates the macro_rules patterns before we build the codegen.

// Re-export proc-macros so bridge macros can reference them via $crate
#[doc(hidden)]
pub use proto_attr_macros::__attr_error as __attr_error_proc_macro;
#[doc(hidden)]
pub use proto_attr_macros::__build_struct_fields;
#[doc(hidden)]
pub use proto_attr_macros::__dispatch_attr;
#[doc(hidden)]
pub use proto_attr_macros::__dispatch_column_field;
#[doc(hidden)]
pub use proto_attr_macros::__field_error as __field_error_proc_macro;
#[doc(hidden)]
pub use proto_attr_macros::__spanned_error;

// ============================================================================
// HAND-WRITTEN TYPES (would be generated by __make_parse_attr!)
// ============================================================================

/// ORM attributes for field and struct configuration.
#[derive(Debug, Clone, PartialEq)]
pub enum Attr {
    /// Skip this field entirely
    Skip,
    /// Rename this field/struct
    Rename(&'static str),
    /// Column configuration
    Column(Column),
}

/// Column configuration for ORM mapping.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Column {
    /// Override the column name
    pub name: Option<&'static str>,
    /// Is this a primary key?
    pub primary_key: bool,
}

// ============================================================================
// HAND-WRITTEN PARSING MACROS (would be generated by __make_parse_attr!)
// ============================================================================

/// Parse an attribute into an `Attr` value.
///
/// Uses proc-macro dispatcher to preserve spans for error messages.
#[macro_export]
macro_rules! __parse_attr {
    // Dispatch via proc-macro to handle all variant types
    ($name:ident $($rest:tt)*) => {
        $crate::__dispatch_attr!{
            @namespace { $crate }
            @enum_name { Attr }
            @variants {
                skip: unit,
                rename: newtype,
                column: rec Column { name: opt_string, primary_key: bool }
            }
            @name { $name }
            @rest { $($rest)* }
        }
    };

    // Error: completely empty
    () => {
        compile_error!("expected an attribute name")
    };
}

// NOTE: The variant-specific macros (__parse_skip, __parse_rename, __parse_column, etc.)
// are no longer needed since __dispatch_attr now handles all parsing directly.
// They have been removed to keep the code clean.

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skip() {
        let attr = __parse_attr!(skip);
        assert_eq!(attr, Attr::Skip);
    }

    #[test]
    fn test_rename_parens() {
        let attr = __parse_attr!(rename("new_name"));
        assert_eq!(attr, Attr::Rename("new_name"));
    }

    #[test]
    fn test_rename_equals() {
        let attr = __parse_attr!(rename = "new_name");
        assert_eq!(attr, Attr::Rename("new_name"));
    }

    #[test]
    fn test_column_empty() {
        let attr = __parse_attr!(column());
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_no_parens() {
        let attr = __parse_attr!(column);
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_name_only() {
        let attr = __parse_attr!(column(name = "user_id"));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_primary_key_flag() {
        let attr = __parse_attr!(column(primary_key));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_primary_key_explicit() {
        let attr = __parse_attr!(column(primary_key = true));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_full() {
        let attr = __parse_attr!(column(name = "user_id", primary_key));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_order_independent() {
        let attr = __parse_attr!(column(primary_key, name = "user_id"));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: true,
            })
        );
    }
}
