//! Example extension crate demonstrating the attribute grammar system.
//!
//! This is the "orm" equivalent - an extension that defines its own attributes.

// NOTE: For Phase 1, we hand-write what `define_attr_grammar!` would generate.
// This validates the macro_rules patterns before we build the codegen.

// Re-export proc-macros so bridge macros can reference them via $crate
#[doc(hidden)]
pub use proto_attr_macros::__attr_error as __attr_error_proc_macro;
#[doc(hidden)]
pub use proto_attr_macros::__field_error as __field_error_proc_macro;

// ============================================================================
// HAND-WRITTEN TYPES (would be generated by __make_parse_attr!)
// ============================================================================

/// ORM attributes for field and struct configuration.
#[derive(Debug, Clone, PartialEq)]
pub enum Attr {
    /// Skip this field entirely
    Skip,
    /// Rename this field/struct
    Rename(&'static str),
    /// Column configuration
    Column(Column),
}

/// Column configuration for ORM mapping.
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Column {
    /// Override the column name
    pub name: Option<&'static str>,
    /// Is this a primary key?
    pub primary_key: bool,
}

// ============================================================================
// HAND-WRITTEN PARSING MACROS (would be generated by __make_parse_attr!)
// ============================================================================

/// Parse an attribute into an `Attr` value.
///
/// Dispatches to variant-specific parsers that handle their own error cases.
/// Unknown attributes fall through to typo detection.
#[macro_export]
macro_rules! __parse_attr {
    // ========================================================================
    // Dispatch to variant-specific parsers
    // Each parser handles valid syntax AND error cases for that variant
    // ========================================================================
    (skip $($rest:tt)*) => {
        $crate::__parse_skip!{ $($rest)* }
    };
    (rename $($rest:tt)*) => {
        $crate::__parse_rename!{ $($rest)* }
    };
    (column $($rest:tt)*) => {
        $crate::__parse_column_variant!{ $($rest)* }
    };

    // ========================================================================
    // Error: unknown attribute → typo detection
    // ========================================================================
    ($name:ident $($rest:tt)*) => {
        $crate::__attr_error_bridge!{
            @known_attrs { skip, rename, column }
            @got_name { $name }
            @got_rest { $($rest)* }
        }
    };

    // ========================================================================
    // Error: completely empty
    // ========================================================================
    () => {
        compile_error!("expected an attribute name")
    };
}

// ============================================================================
// SKIP VARIANT PARSER
// ============================================================================

/// Parse the `skip` attribute (unit variant, no arguments).
#[macro_export]
#[doc(hidden)]
macro_rules! __parse_skip {
    // Valid: no arguments
    () => {
        $crate::Attr::Skip
    };

    // Error: parentheses with content
    (($($args:tt)+)) => {
        compile_error!("`skip` does not take arguments; use just `skip`")
    };

    // Error: empty parentheses (allowed but unnecessary)
    (()) => {
        $crate::Attr::Skip
    };

    // Error: equals syntax
    (= $($rest:tt)*) => {
        compile_error!("`skip` does not take a value; use just `skip`")
    };

    // Error: any other trailing tokens
    ($($rest:tt)+) => {
        compile_error!("`skip` does not take arguments; use just `skip`")
    };
}

// ============================================================================
// RENAME VARIANT PARSER
// ============================================================================

/// Parse the `rename` attribute (newtype variant, requires a string literal).
#[macro_export]
#[doc(hidden)]
macro_rules! __parse_rename {
    // Valid: parens style with string literal
    (($lit:literal)) => {
        $crate::Attr::Rename($lit)
    };

    // Valid: equals style with string literal
    (= $lit:literal) => {
        $crate::Attr::Rename($lit)
    };

    // Error: no value provided
    () => {
        compile_error!(
            "`rename` requires a string value: `rename(\"name\")` or `rename = \"name\"`"
        )
    };

    // Error: empty parens
    (()) => {
        compile_error!("`rename` requires a string value: `rename(\"name\")`")
    };

    // Error: multiple values in parens
    (($a:tt $b:tt $($rest:tt)*)) => {
        compile_error!("`rename` takes exactly one string literal: `rename(\"name\")`")
    };

    // Error: equals with no value after
    (=) => {
        compile_error!("`rename` requires a value after `=`: `rename = \"name\"`")
    };

    // Error: something other than literal after equals (catch-all for = case)
    (= $($rest:tt)+) => {
        compile_error!("`rename` expects a string literal: `rename = \"name\"`")
    };

    // Error: parens with non-literal (will fail to match literal pattern above)
    (($($inner:tt)*)) => {
        compile_error!("`rename` expects a string literal: `rename(\"name\")`")
    };

    // Error: any other syntax
    ($($rest:tt)+) => {
        compile_error!("`rename` expects: `rename(\"name\")` or `rename = \"name\"`")
    };
}

// ============================================================================
// COLUMN VARIANT PARSER (entry point)
// ============================================================================

/// Parse the `column` attribute (struct variant with optional fields).
#[macro_export]
#[doc(hidden)]
macro_rules! __parse_column_variant {
    // Valid: with parentheses containing fields
    (($($fields:tt)*)) => {
        $crate::__parse_column_fields!{
            @slots { @name { None } @primary_key { false } }
            @rest { $($fields)* }
        }
    };

    // Valid: no parentheses (use all defaults)
    () => {
        $crate::Attr::Column($crate::Column {
            name: None,
            primary_key: false,
        })
    };

    // Error: equals syntax not supported for struct variants
    (= $($rest:tt)*) => {
        compile_error!("`column` uses parentheses syntax: `column(name = \"...\", primary_key)`")
    };

    // Error: any other trailing tokens
    ($($rest:tt)+) => {
        compile_error!("`column` expects parentheses: `column(...)` or just `column`")
    };
}

// ============================================================================
// COLUMN FIELD PARSER
// ============================================================================

/// Parse fields for the `column` struct variant.
///
/// Uses slot-based tracking to avoid duplicate field errors.
#[macro_export]
#[doc(hidden)]
macro_rules! __parse_column_fields {
    // ========================================================================
    // Terminal: all input consumed, build the struct from slots
    // ========================================================================
    (@slots { @name { $name:expr } @primary_key { $pk:expr } } @rest {}) => {
        $crate::Attr::Column($crate::Column {
            name: $name,
            primary_key: $pk,
        })
    };
    (@slots { @name { $name:expr } @primary_key { $pk:expr } } @rest { , }) => {
        $crate::Attr::Column($crate::Column {
            name: $name,
            primary_key: $pk,
        })
    };

    // ========================================================================
    // Field: name = "..."
    // ========================================================================
    (@slots { @name { $_old:expr } @primary_key { $pk:expr } } @rest { name = $lit:literal $($rest:tt)* }) => {
        $crate::__parse_column_fields!{
            @slots { @name { Some($lit) } @primary_key { $pk } }
            @rest { $($rest)* }
        }
    };

    // Error: name without value
    (@slots { $($slots:tt)* } @rest { name $($rest:tt)* }) => {
        $crate::__parse_name_field!{ $($rest)* }
    };

    // ========================================================================
    // Field: primary_key = true/false (must come before the flag pattern!)
    // ========================================================================
    (@slots { @name { $name:expr } @primary_key { $_old:expr } } @rest { primary_key = true $($rest:tt)* }) => {
        $crate::__parse_column_fields!{
            @slots { @name { $name } @primary_key { true } }
            @rest { $($rest)* }
        }
    };
    (@slots { @name { $name:expr } @primary_key { $_old:expr } } @rest { primary_key = false $($rest:tt)* }) => {
        $crate::__parse_column_fields!{
            @slots { @name { $name } @primary_key { false } }
            @rest { $($rest)* }
        }
    };

    // Field: primary_key (bool flag, no value = true)
    (@slots { @name { $name:expr } @primary_key { $_old:expr } } @rest { primary_key $($rest:tt)* }) => {
        $crate::__parse_column_fields!{
            @slots { @name { $name } @primary_key { true } }
            @rest { $($rest)* }
        }
    };

    // ========================================================================
    // Skip leading/trailing commas
    // ========================================================================
    (@slots { $($slots:tt)* } @rest { , $($rest:tt)* }) => {
        $crate::__parse_column_fields!{ @slots { $($slots)* } @rest { $($rest)* } }
    };

    // ========================================================================
    // Error fallback: unknown field → typo detection
    // ========================================================================
    (@slots { $($slots:tt)* } @rest { $field_name:ident $($rest:tt)* }) => {
        $crate::__field_error_bridge!{
            @struct_name { Column }
            @known_fields { name, primary_key }
            @got_name { $field_name }
            @got_rest { $($rest)* }
        }
    };
}

/// Helper to provide better error for `name` field without `=`
#[macro_export]
#[doc(hidden)]
macro_rules! __parse_name_field {
    // name, ... or name (end) - missing value
    (, $($rest:tt)*) => {
        compile_error!("`name` requires a string value: `name = \"column_name\"`")
    };
    () => {
        compile_error!("`name` requires a string value: `name = \"column_name\"`")
    };
    // name(...) - wrong syntax
    (($($inner:tt)*) $($rest:tt)*) => {
        compile_error!("`name` uses equals syntax: `name = \"column_name\"`, not `name(...)`")
    };
    // Anything else
    ($($rest:tt)*) => {
        compile_error!("`name` requires a string value: `name = \"column_name\"`")
    };
}

// ============================================================================
// BRIDGE MACROS (to call proc-macros with @-prefixed args)
// ============================================================================

/// Bridge macro to call the proc-macro for attribute errors.
/// Uses $crate to reference the re-exported proc-macro, making it work cross-crate.
#[macro_export]
#[doc(hidden)]
macro_rules! __attr_error_bridge {
    ($($tt:tt)*) => {
        $crate::__attr_error_proc_macro!{ $($tt)* }
    };
}

/// Bridge macro to call the proc-macro for field errors.
/// Uses $crate to reference the re-exported proc-macro, making it work cross-crate.
#[macro_export]
#[doc(hidden)]
macro_rules! __field_error_bridge {
    ($($tt:tt)*) => {
        $crate::__field_error_proc_macro!{ $($tt)* }
    };
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_skip() {
        let attr = __parse_attr!(skip);
        assert_eq!(attr, Attr::Skip);
    }

    #[test]
    fn test_rename_parens() {
        let attr = __parse_attr!(rename("new_name"));
        assert_eq!(attr, Attr::Rename("new_name"));
    }

    #[test]
    fn test_rename_equals() {
        let attr = __parse_attr!(rename = "new_name");
        assert_eq!(attr, Attr::Rename("new_name"));
    }

    #[test]
    fn test_column_empty() {
        let attr = __parse_attr!(column());
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_no_parens() {
        let attr = __parse_attr!(column);
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_name_only() {
        let attr = __parse_attr!(column(name = "user_id"));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: false,
            })
        );
    }

    #[test]
    fn test_column_primary_key_flag() {
        let attr = __parse_attr!(column(primary_key));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_primary_key_explicit() {
        let attr = __parse_attr!(column(primary_key = true));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: None,
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_full() {
        let attr = __parse_attr!(column(name = "user_id", primary_key));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: true,
            })
        );
    }

    #[test]
    fn test_column_order_independent() {
        let attr = __parse_attr!(column(primary_key, name = "user_id"));
        assert_eq!(
            attr,
            Attr::Column(Column {
                name: Some("user_id"),
                primary_key: true,
            })
        );
    }
}
