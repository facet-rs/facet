/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * crates.io
 * 
__Experimental API documentation for the [crates.io](https://crates.io/)
package registry.__

This document describes the API used by the crates.io website, cargo
client, and other third-party tools to interact with the crates.io
registry.

Before using this API, please read the
[crates.io data access policy](https://crates.io/data-access) and ensure
that your use of the API complies with the policy.

__The API is under active development and may change at any time__,
though we will try to avoid breaking changes where possible.

Some parts of the API follow the "Registry Web API" spec documented
at <https://doc.rust-lang.org/cargo/reference/registry-web-api.html>
and can be considered stable.

Most parts of the API do not require authentication. The endpoints
that do require authentication are marked as such in the documentation,
with some requiring cookie authentication (usable only by the web UI)
and others requiring API token authentication (usable by cargo and
other clients).

 * OpenAPI spec version: 0.0.0
 */
/**
 * `None` or a list of crate scope patterns (see RFC #2947).
 */
export type ApiTokenCrateScopes = string[] | null;

/**
 * A list of endpoint scopes or `None` for the `legacy` endpoint scope (see RFC #2947).
 */
export type ApiTokenEndpointScopes = EndpointScope[] | null;

/**
 * The date and time when the token will expire, or `null`.
 */
export type ApiTokenExpiredAt = string | null;

/**
 * The date and time when the token was last used.
 */
export type ApiTokenLastUsedAt = string | null;

/**
 * The model representing a row in the `api_tokens` database table.
 */
export interface ApiToken {
  /** `None` or a list of crate scope patterns (see RFC #2947). */
  crate_scopes?: ApiTokenCrateScopes;
  /** The date and time when the token was created. */
  created_at: string;
  /** A list of endpoint scopes or `None` for the `legacy` endpoint scope (see RFC #2947). */
  endpoint_scopes?: ApiTokenEndpointScopes;
  /** The date and time when the token will expire, or `null`. */
  expired_at?: ApiTokenExpiredAt;
  /** An opaque unique identifier for the token. */
  id: number;
  /** The date and time when the token was last used. */
  last_used_at?: ApiTokenLastUsedAt;
  /** The name of the token. */
  name: string;
}

/**
 * The user's avatar URL, if set.
 */
export type AuthenticatedUserAvatar = string | null;

/**
 * The user's email address, if set.
 */
export type AuthenticatedUserEmail = string | null;

/**
 * The user's display name, if set.
 */
export type AuthenticatedUserName = string | null;

/**
 * The user's GitHub profile URL.
 */
export type AuthenticatedUserUrl = string | null;

export interface AuthenticatedUser {
  /** The user's avatar URL, if set. */
  avatar?: AuthenticatedUserAvatar;
  /** The user's email address, if set. */
  email?: AuthenticatedUserEmail;
  /** Whether the user's email address verification email has been sent. */
  email_verification_sent: boolean;
  /** Whether the user's email address has been verified. */
  email_verified: boolean;
  /** An opaque identifier for the user. */
  id: number;
  /** Whether the user is a crates.io administrator. */
  is_admin: boolean;
  /** The user's login name. */
  login: string;
  /** The user's display name, if set. */
  name?: AuthenticatedUserName;
  /** Whether the user has opted in to receive publish notifications via email. */
  publish_notifications: boolean;
  /** The user's GitHub profile URL. */
  url?: AuthenticatedUserUrl;
}

/**
 * The parent categories of this category.

This field is only present when the category details are queried,
but not when listing categories.
 */
export type CategoryParentCategories = Category[] | null;

/**
 * The subcategories of this category.

This field is only present when the category details are queried,
but not when listing categories.
 */
export type CategorySubcategories = Category[] | null;

export interface Category {
  /** The name of the category. */
  category: string;
  /** The total number of crates that have this category. */
  crates_cnt: number;
  /** The date and time this category was created. */
  created_at: string;
  /** A description of the category. */
  description: string;
  /** An opaque identifier for the category. */
  id: string;
  /** The parent categories of this category.

This field is only present when the category details are queried,
but not when listing categories. */
  parent_categories?: CategoryParentCategories;
  /** The "slug" of the category.

See <https://crates.io/category_slugs>. */
  slug: string;
  /** The subcategories of this category.

This field is only present when the category details are queried,
but not when listing categories. */
  subcategories?: CategorySubcategories;
}

export type CrateBadgesItem = { [key: string]: unknown };

/**
 * The list of categories belonging to this crate.
 */
export type CrateCategories = string[] | null;

/**
 * The "default" version of this crate.

This version will be displayed by default on the crate's page.
 */
export type CrateDefaultVersion = string | null;

/**
 * Description of the crate.
 */
export type CrateDescription = string | null;

/**
 * The URL to the crate's documentation, if set.
 */
export type CrateDocumentation = string | null;

/**
 * The URL to the crate's homepage, if set.
 */
export type CrateHomepage = string | null;

/**
 * The list of keywords belonging to this crate.
 */
export type CrateKeywords = string[] | null;

/**
 * The highest version number for this crate that is not a pre-release.
 * @deprecated
 */
export type CrateMaxStableVersion = string | null;

/**
 * The total number of downloads for this crate in the last 90 days.
 */
export type CrateRecentDownloads = number | null;

/**
 * The URL to the crate's repository, if set.
 */
export type CrateRepository = string | null;

/**
 * The list of version IDs belonging to this crate.
 */
export type CrateVersions = number[] | null;

export interface Crate {
  /** @deprecated */
  badges: CrateBadgesItem[];
  /** The list of categories belonging to this crate. */
  categories?: CrateCategories;
  /** The date and time this crate was created. */
  created_at: string;
  /** The "default" version of this crate.

This version will be displayed by default on the crate's page. */
  default_version?: CrateDefaultVersion;
  /** Description of the crate. */
  description?: CrateDescription;
  /** The URL to the crate's documentation, if set. */
  documentation?: CrateDocumentation;
  /** The total number of downloads for this crate. */
  downloads: number;
  /**
   * Whether the crate name was an exact match.
   * @deprecated
   */
  exact_match: boolean;
  /** The URL to the crate's homepage, if set. */
  homepage?: CrateHomepage;
  /** An opaque identifier for the crate. */
  id: string;
  /** The list of keywords belonging to this crate. */
  keywords?: CrateKeywords;
  /** Links to other API endpoints related to this crate. */
  links: CrateLinks;
  /**
   * The highest version number for this crate that is not a pre-release.
   * @deprecated
   */
  max_stable_version?: CrateMaxStableVersion;
  /**
   * The highest version number for this crate.
   * @deprecated
   */
  max_version: string;
  /** The name of the crate. */
  name: string;
  /**
   * The most recently published version for this crate.
   * @deprecated
   */
  newest_version: string;
  /** The total number of versions for this crate. */
  num_versions: number;
  /** The total number of downloads for this crate in the last 90 days. */
  recent_downloads?: CrateRecentDownloads;
  /** The URL to the crate's repository, if set. */
  repository?: CrateRepository;
  /** Whether this crate can only be published via Trusted Publishing. */
  trustpub_only: boolean;
  /** The date and time this crate was last updated. */
  updated_at: string;
  /** The list of version IDs belonging to this crate. */
  versions?: CrateVersions;
  /** Whether all versions of this crate have been yanked. */
  yanked: boolean;
}

/**
 * The API path to this crate's team owners.
 */
export type CrateLinksOwnerTeam = string | null;

/**
 * The API path to this crate's user owners.
 */
export type CrateLinksOwnerUser = string | null;

/**
 * The API path to this crate's owners.
 */
export type CrateLinksOwners = string | null;

/**
 * The API path to this crate's versions.
 */
export type CrateLinksVersions = string | null;

export interface CrateLinks {
  /** The API path to this crate's team owners. */
  owner_team?: CrateLinksOwnerTeam;
  /** The API path to this crate's user owners. */
  owner_user?: CrateLinksOwnerUser;
  /** The API path to this crate's owners. */
  owners?: CrateLinksOwners;
  /** The API path to this crate's reverse dependencies. */
  reverse_dependencies: string;
  /** The API path to this crate's download statistics. */
  version_downloads: string;
  /** The API path to this crate's versions. */
  versions?: CrateLinksVersions;
}

export interface CrateOwnerInvitation {
  /** The ID of the crate that the user was invited to be an owner of. */
  crate_id: number;
  /** The name of the crate that the user was invited to be an owner of. */
  crate_name: string;
  /** The date and time this invitation was created. */
  created_at: string;
  /** The date and time this invitation will expire. */
  expires_at: string;
  /** The ID of the user who was invited to be a crate owner. */
  invitee_id: number;
  /** The ID of the user who sent the invitation. */
  inviter_id: number;
}

export type EncodableApiTokenWithTokenAllOf = {
  /** The plaintext API token.

Only available when the token is created. */
  token: string;
};

export type EncodableApiTokenWithToken = ApiToken & EncodableApiTokenWithTokenAllOf;

/**
 * The target platform for this dependency, if any.
 */
export type EncodableDependencyTarget = string | null;

export interface EncodableDependency {
  /** The name of the crate this dependency points to. */
  crate_id: string;
  /** Whether default features are enabled for this dependency. */
  default_features: boolean;
  /** The total number of downloads for the crate this dependency points to. */
  downloads: number;
  /** The features explicitly enabled for this dependency. */
  features: string[];
  /** An opaque identifier for the dependency. */
  id: number;
  /** The type of dependency this is (normal, dev, or build). */
  kind: string;
  /** Whether this dependency is optional. */
  optional: boolean;
  /** The version requirement for this dependency. */
  req: string;
  /** The target platform for this dependency, if any. */
  target?: EncodableDependencyTarget;
  /** The ID of the version this dependency belongs to. */
  version_id: number;
}

export type EndpointScope = typeof EndpointScope[keyof typeof EndpointScope];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EndpointScope = {
  'publish-new': 'publish-new',
  'publish-update': 'publish-update',
  'trusted-publishing': 'trusted-publishing',
  yank: 'yank',
  'change-owners': 'change-owners',
} as const;

export type GitHubConfigEnvironment = string | null;

export interface GitHubConfig {
  crate: string;
  created_at: string;
  environment?: GitHubConfigEnvironment;
  id: number;
  repository_name: string;
  repository_owner: string;
  repository_owner_id: number;
  workflow_filename: string;
}

export type GitLabConfigEnvironment = string | null;

export type GitLabConfigNamespaceId = string | null;

export interface GitLabConfig {
  crate: string;
  created_at: string;
  environment?: GitLabConfigEnvironment;
  id: number;
  namespace: string;
  namespace_id?: GitLabConfigNamespaceId;
  project: string;
  workflow_filepath: string;
}

export interface Keyword {
  /** The total number of crates that have this keyword. */
  crates_cnt: number;
  /** The date and time this keyword was created. */
  created_at: string;
  /** An opaque identifier for the keyword. */
  id: string;
  /** The keyword itself. */
  keyword: string;
}

export interface LegacyCrateOwnerInvitation {
  /** The ID of the crate that the user was invited to be an owner of. */
  crate_id: number;
  /** The name of the crate that the user was invited to be an owner of. */
  crate_name: string;
  /** The date and time this invitation was created. */
  created_at: string;
  /** The date and time this invitation will expire. */
  expires_at: string;
  /** The username of the user who sent the invitation. */
  invited_by_username: string;
  /** The ID of the user who was invited to be a crate owner. */
  invitee_id: number;
  /** The ID of the user who sent the invitation. */
  inviter_id: number;
}

export type NewGitHubConfigEnvironment = string | null;

export interface NewGitHubConfig {
  crate: string;
  environment?: NewGitHubConfigEnvironment;
  repository_name: string;
  repository_owner: string;
  workflow_filename: string;
}

export type NewGitLabConfigEnvironment = string | null;

export interface NewGitLabConfig {
  crate: string;
  environment?: NewGitLabConfigEnvironment;
  namespace: string;
  project: string;
  workflow_filepath: string;
}

/**
 * The avatar URL of the team or user.
 */
export type OwnerAvatar = string | null;

/**
 * The display name of the team or user.
 */
export type OwnerName = string | null;

/**
 * The URL to the owner's profile.
 */
export type OwnerUrl = string | null;

export interface Owner {
  /** The avatar URL of the team or user. */
  avatar?: OwnerAvatar;
  /** The opaque identifier for the team or user, depending on the `kind` field. */
  id: number;
  /** The kind of the owner (`user` or `team`). */
  kind: string;
  /** The login name of the team or user. */
  login: string;
  /** The display name of the team or user. */
  name?: OwnerName;
  /** The URL to the owner's profile. */
  url?: OwnerUrl;
}

export interface PatchRequest {
  /** The crate settings to update. */
  crate: PatchRequestCrate;
}

/**
 * Whether this crate can only be published via Trusted Publishing.
 */
export type PatchRequestCrateTrustpubOnly = boolean | null;

export interface PatchRequestCrate {
  /** Whether this crate can only be published via Trusted Publishing. */
  trustpub_only?: PatchRequestCrateTrustpubOnly;
}

export interface PublishWarnings {
  /** @deprecated */
  invalid_badges: string[];
  invalid_categories: string[];
  other: string[];
}

export interface Slug {
  /** A description of the category. */
  description: string;
  /** An opaque identifier for the category. */
  id: string;
  /** The "slug" of the category.

See <https://crates.io/category_slugs>. */
  slug: string;
}

/**
 * The avatar URL of the team.
 */
export type TeamAvatar = string | null;

/**
 * The display name of the team.
 */
export type TeamName = string | null;

/**
 * The GitHub profile URL of the team.
 */
export type TeamUrl = string | null;

export interface Team {
  /** The avatar URL of the team. */
  avatar?: TeamAvatar;
  /** An opaque identifier for the team. */
  id: number;
  /** The login name of the team. */
  login: string;
  /** The display name of the team. */
  name?: TeamName;
  /** The GitHub profile URL of the team. */
  url?: TeamUrl;
}

/**
 * The user's avatar URL, if set.
 */
export type UserAvatar = string | null;

/**
 * The user's display name, if set.
 */
export type UserName = string | null;

export interface User {
  /** The user's avatar URL, if set. */
  avatar?: UserAvatar;
  /** An opaque identifier for the user. */
  id: number;
  /** The user's login name. */
  login: string;
  /** The user's display name, if set. */
  name?: UserName;
  /** The user's GitHub profile URL. */
  url: string;
}

export type VersionAuditActionsItem = {
  /** The action that was performed. */
  action: string;
  /** The date and time the action was performed. */
  time: string;
  /** The user who performed the action. */
  user: User;
};

export type VersionBinNamesAnyOfItem = string | null;

/**
 * The names of the binaries provided by this version, if any.
 */
export type VersionBinNames = VersionBinNamesAnyOfItem[] | null;

/**
 * The description of this version of the crate.
 */
export type VersionDescription = string | null;

/**
 * The URL to the crate's documentation, if set.
 */
export type VersionDocumentation = string | null;

/**
 * The Rust Edition used to compile this version, if set.
 */
export type VersionEdition = string | null;

/**
 * The features defined by this version.
 */
export type VersionFeatures = { [key: string]: unknown };

/**
 * Whether this version can be used as a library.
 */
export type VersionHasLib = boolean | null;

/**
 * The URL to the crate's homepage, if set.
 */
export type VersionHomepage = string | null;

/**
 * The name of the native library this version links with, if any.
 */
export type VersionLibLinks = string | null;

/**
 * The license of this version of the crate.
 */
export type VersionLicense = string | null;

/**
 * Line count statistics for this version.

Status: **Unstable**

This field may be `null` until the version has been analyzed, which
happens in an asynchronous background job.
 */
export type VersionLinecounts = { [key: string]: unknown };

export type VersionPublishedBy = null | User;

/**
 * The URL to the crate's repository, if set.
 */
export type VersionRepository = string | null;

/**
 * The minimum version of the Rust compiler required to compile
this version, if set.
 */
export type VersionRustVersion = string | null;

/**
 * Information about the trusted publisher that published this version, if any.

Status: **Unstable**

This field is filled if the version was published via trusted publishing
(e.g., GitHub Actions) rather than a regular API token.

The exact structure of this field depends on the `provider` field
inside it.
 */
export type VersionTrustpubDataAnyOf = { [key: string]: unknown };

/**
 * Information about the trusted publisher that published this version, if any.

Status: **Unstable**

This field is filled if the version was published via trusted publishing
(e.g., GitHub Actions) rather than a regular API token.

The exact structure of this field depends on the `provider` field
inside it.
 */
export type VersionTrustpubData = VersionTrustpubDataAnyOf | null;

/**
 * The message given when this version was yanked, if any.
 */
export type VersionYankMessage = string | null;

export interface Version {
  /** A list of actions performed on this version. */
  audit_actions: VersionAuditActionsItem[];
  /** The names of the binaries provided by this version, if any. */
  bin_names?: VersionBinNames;
  /** The SHA256 checksum of the compressed crate file encoded as a
hexadecimal string. */
  checksum: string;
  /** The name of the crate. */
  crate: string;
  /** The size of the compressed crate file in bytes. */
  crate_size: number;
  /** The date and time this version was created. */
  created_at: string;
  /** The description of this version of the crate. */
  description?: VersionDescription;
  /** The API path to download the crate. */
  dl_path: string;
  /** The URL to the crate's documentation, if set. */
  documentation?: VersionDocumentation;
  /** The total number of downloads for this version. */
  downloads: number;
  /** The Rust Edition used to compile this version, if set. */
  edition?: VersionEdition;
  /** The features defined by this version. */
  features: VersionFeatures;
  /** Whether this version can be used as a library. */
  has_lib?: VersionHasLib;
  /** The URL to the crate's homepage, if set. */
  homepage?: VersionHomepage;
  /** An opaque identifier for the version. */
  id: number;
  /** The name of the native library this version links with, if any. */
  lib_links?: VersionLibLinks;
  /** The license of this version of the crate. */
  license?: VersionLicense;
  /** Line count statistics for this version.

Status: **Unstable**

This field may be `null` until the version has been analyzed, which
happens in an asynchronous background job. */
  linecounts: VersionLinecounts;
  /** Links to other API endpoints related to this version. */
  links: VersionLinks;
  /** The version number. */
  num: string;
  published_by?: VersionPublishedBy;
  /** The API path to download the crate's README file as HTML code. */
  readme_path: string;
  /** The URL to the crate's repository, if set. */
  repository?: VersionRepository;
  /** The minimum version of the Rust compiler required to compile
this version, if set. */
  rust_version?: VersionRustVersion;
  /** Information about the trusted publisher that published this version, if any.

Status: **Unstable**

This field is filled if the version was published via trusted publishing
(e.g., GitHub Actions) rather than a regular API token.

The exact structure of this field depends on the `provider` field
inside it. */
  trustpub_data?: VersionTrustpubData;
  /** The date and time this version was last updated (i.e. yanked or unyanked). */
  updated_at: string;
  /** The message given when this version was yanked, if any. */
  yank_message?: VersionYankMessage;
  /** Whether this version has been yanked. */
  yanked: boolean;
}

export interface VersionDownload {
  /** The date this download count is for. */
  date: string;
  /** The number of downloads for this version on the given date. */
  downloads: number;
  /** The ID of the version this download count is for. */
  version: number;
}

export interface VersionLinks {
  /**
   * The API path to download this version's authors.
   * @deprecated
   */
  authors: string;
  /** The API path to download this version's dependencies. */
  dependencies: string;
  /** The API path to download this version's download numbers. */
  version_downloads: string;
}

export type ListCrateOwnerInvitationsParams = {
/**
 * Filter crate owner invitations by crate name.

Only crate owners can query pending invitations for their crate.
 */
crate_name?: string;
/**
 * The ID of the user who was invited to be a crate owner.

This parameter needs to match the authenticated user's ID.
 */
invitee_id?: number;
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

/**
 * Query parameter string to fetch the next page of results.
 */
export type ListCrateOwnerInvitations200MetaNextPage = string | null;

export type ListCrateOwnerInvitations200Meta = {
  /** Query parameter string to fetch the next page of results. */
  next_page?: ListCrateOwnerInvitations200MetaNextPage;
};

export type ListCrateOwnerInvitations200 = {
  /** The list of crate owner invitations. */
  invitations: CrateOwnerInvitation[];
  meta: ListCrateOwnerInvitations200Meta;
  /** The list of users referenced in the crate owner invitations. */
  users: User[];
};

export type AuthorizeSession200OwnedCratesItem = {
  /** @deprecated */
  email_notifications: boolean;
  /** The opaque identifier of the crate. */
  id: number;
  /** The name of the crate. */
  name: string;
};

export type AuthorizeSession200 = {
  /** The crates that the authenticated user owns. */
  owned_crates: AuthorizeSession200OwnedCratesItem[];
  /** The authenticated user. */
  user: AuthenticatedUser;
};

export type BeginSession200 = {
  state: string;
  url: string;
};

export type ListCategoriesParams = {
/**
 * The sort order of the categories.

Valid values: `alpha`, and `crates`.

Defaults to `alpha`.
 */
sort?: string;
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

export type ListCategories200Meta = {
  /** The total number of categories. */
  total: number;
};

export type ListCategories200 = {
  /** The list of categories. */
  categories: Category[];
  meta: ListCategories200Meta;
};

export type FindCategory200 = {
  category: Category;
};

export type ListCategorySlugs200 = {
  /** The list of category slugs. */
  category_slugs: Slug[];
};

export type ConfirmUserEmail200 = {
  ok: boolean;
};

export type ListCratesParams = {
/**
 * The sort order of the crates.

Valid values: `alphabetical`, `relevance`, `downloads`,
`recent-downloads`, `recent-updates`, `new`.

Defaults to `relevance` if `q` is set, otherwise `alphabetical`.
 */
sort?: string;
/**
 * A string that does not contain null bytes (`\0`).
 */
q?: string;
/**
 * Set to `yes` to include yanked crates.
 */
include_yanked?: string;
/**
 * A string that does not contain null bytes (`\0`).
 */
category?: string;
/**
 * A string that does not contain null bytes (`\0`).
 */
all_keywords?: string;
/**
 * A string that does not contain null bytes (`\0`).
 */
keyword?: string;
/**
 * A string that does not contain null bytes (`\0`).
 */
letter?: string;
/**
 * If set, only crates owned by the given crates.io user ID are returned
(ignored if `all_keywords`, `keyword`, or `letter` are set).
 */
user_id?: number;
/**
 * If set, only crates owned by the given crates.io team ID are returned
(ignored if `all_keywords`, `keyword`, `letter`, or `user_id` are set).
 */
team_id?: number;
/**
 * If set, only crates owned by users the current user follows are returned
(ignored if `all_keywords`, `keyword`, `letter`, `user_id`,
or `team_id` are set).

The exact value of this parameter is ignored, but it must not be empty.
 */
following?: string;
/**
 * If set, only crates with the specified names are returned (ignored
if `all_keywords`, `keyword`, `letter`, `user_id`, `team_id`,
or `following` are set).
 */
'ids[]'?: string[];
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

/**
 * Query string to the next page of results, if any.
 */
export type ListCrates200MetaNextPage = string | null;

/**
 * Query string to the previous page of results, if any.
 */
export type ListCrates200MetaPrevPage = string | null;

export type ListCrates200Meta = {
  /** Query string to the next page of results, if any. */
  next_page?: ListCrates200MetaNextPage;
  /** Query string to the previous page of results, if any. */
  prev_page?: ListCrates200MetaPrevPage;
  /** The total number of crates that match the query. */
  total: number;
};

export type ListCrates200 = {
  crates: Crate[];
  meta: ListCrates200Meta;
};

/**
 * The categories of the crate.
 */
export type FindNewCrate200Categories = Category[] | null;

/**
 * The keywords of the crate.
 */
export type FindNewCrate200Keywords = Keyword[] | null;

/**
 * The versions of the crate.
 */
export type FindNewCrate200Versions = Version[] | null;

export type FindNewCrate200 = {
  /** The categories of the crate. */
  categories?: FindNewCrate200Categories;
  /** The crate metadata. */
  crate: Crate;
  /** The keywords of the crate. */
  keywords?: FindNewCrate200Keywords;
  /** The versions of the crate. */
  versions?: FindNewCrate200Versions;
};

export type Publish200 = {
  crate: Crate;
  warnings: PublishWarnings;
};

export type FindCrateParams = {
/**
 * Additional data to include in the response.

Valid values: `versions`, `keywords`, `categories`, `badges`,
`downloads`, `default_version`, or `full`.

Defaults to `full` for backwards compatibility.

**Note**: `versions` and `default_version` share the same key `versions`, therefore `default_version` will be ignored if both are provided.

This parameter expects a comma-separated list of values.
 */
include?: string;
};

/**
 * The categories of the crate.
 */
export type FindCrate200Categories = Category[] | null;

/**
 * The keywords of the crate.
 */
export type FindCrate200Keywords = Keyword[] | null;

/**
 * The versions of the crate.
 */
export type FindCrate200Versions = Version[] | null;

export type FindCrate200 = {
  /** The categories of the crate. */
  categories?: FindCrate200Categories;
  /** The crate metadata. */
  crate: Crate;
  /** The keywords of the crate. */
  keywords?: FindCrate200Keywords;
  /** The versions of the crate. */
  versions?: FindCrate200Versions;
};

export type DeleteCrateParams = {
message?: string;
};

export type UpdateCrate200 = {
  /** The updated crate metadata. */
  crate: Crate;
};

export type GetCrateDownloadsParams = {
/**
 * Additional data to include in the response.

Valid values: `versions`.

Defaults to no additional data.

This parameter expects a comma-separated list of values.
 */
include?: string;
};

export type GetCrateDownloads200MetaExtraDownloadsItem = {
  /** The date this download count is for. */
  date: string;
  /** The number of downloads on the given date. */
  downloads: number;
};

export type GetCrateDownloads200Meta = {
  extra_downloads: GetCrateDownloads200MetaExtraDownloadsItem[];
};

/**
 * The versions referenced in the download counts, if `?include=versions`
was requested.
 */
export type GetCrateDownloads200Versions = Version[] | null;

export type GetCrateDownloads200 = {
  meta: GetCrateDownloads200Meta;
  /** The per-day download counts for the last 90 days. */
  version_downloads: VersionDownload[];
  /** The versions referenced in the download counts, if `?include=versions`
was requested. */
  versions?: GetCrateDownloads200Versions;
};

export type FollowCrate200 = {
  ok: boolean;
};

export type UnfollowCrate200 = {
  ok: boolean;
};

export type GetFollowingCrate200 = {
  /** Whether the authenticated user is following the crate. */
  following: boolean;
};

export type GetTeamOwners200 = {
  teams: Owner[];
};

export type GetUserOwners200 = {
  users: Owner[];
};

export type ListOwners200 = {
  users: Owner[];
};

export type AddOwnersBody = {
  /** List of owner login names to add or remove.

For users, use just the username (e.g., `"octocat"`).
For GitHub teams, use the format `github:org:team` (e.g., `"github:rust-lang:owners"`). */
  owners: string[];
};

export type AddOwners200 = {
  /** A message describing the result of the operation. */
  msg: string;
  ok: boolean;
};

export type RemoveOwnersBody = {
  /** List of owner login names to add or remove.

For users, use just the username (e.g., `"octocat"`).
For GitHub teams, use the format `github:org:team` (e.g., `"github:rust-lang:owners"`). */
  owners: string[];
};

export type RemoveOwners200 = {
  /** A message describing the result of the operation. */
  msg: string;
  ok: boolean;
};

export type ListReverseDependencies200Meta = {
  total: number;
};

export type ListReverseDependencies200 = {
  /** The list of reverse dependencies of the crate. */
  dependencies: EncodableDependency[];
  meta: ListReverseDependencies200Meta;
  /** The versions referenced in the `dependencies` field. */
  versions: Version[];
};

export type ListVersionsParams = {
/**
 * Additional data to include in the response.

Valid values: `release_tracks`.

Defaults to no additional data.

This parameter expects a comma-separated list of values.
 */
include?: string;
/**
 * The sort order of the versions.

Valid values: `date`, and `semver`.

Defaults to `semver`.
 */
sort?: string;
/**
 * If set, only versions with the specified semver strings are returned.
 */
'nums[]'?: string[];
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

/**
 * Query string to the next page of results, if any.
 */
export type ListVersions200MetaNextPage = string | null;

/**
 * Additional data about the crate's release tracks,
if `?include=release_tracks` is used.
 */
export type ListVersions200MetaReleaseTracksAnyOf = { [key: string]: unknown };

/**
 * Additional data about the crate's release tracks,
if `?include=release_tracks` is used.
 */
export type ListVersions200MetaReleaseTracks = ListVersions200MetaReleaseTracksAnyOf | null;

export type ListVersions200Meta = {
  /** Query string to the next page of results, if any. */
  next_page?: ListVersions200MetaNextPage;
  /** Additional data about the crate's release tracks,
if `?include=release_tracks` is used. */
  release_tracks?: ListVersions200MetaReleaseTracks;
  /** The total number of versions belonging to the crate. */
  total: number;
};

export type ListVersions200 = {
  meta: ListVersions200Meta;
  versions: Version[];
};

export type FindVersion200 = {
  version: Version;
};

export type UpdateVersion200 = {
  version: Version;
};

export type GetVersionDependencies200 = {
  dependencies: EncodableDependency[];
};

export type DownloadVersion200 = {
  /** The URL to the crate file. */
  url: string;
};

export type GetVersionDownloadsParams = {
/**
 * Only return download counts before this date.
 */
before_date?: string;
};

export type GetVersionDownloads200 = {
  version_downloads: VersionDownload[];
};

export type GetVersionReadme200 = {
  /** The URL to the readme file. */
  url: string;
};

export type UnyankVersion200 = {
  ok: boolean;
};

export type YankVersion200 = {
  ok: boolean;
};

export type ListKeywordsParams = {
/**
 * The sort order of the keywords.

Valid values: `alpha`, and `crates`.

Defaults to `alpha`.
 */
sort?: string;
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

export type ListKeywords200Meta = {
  /** The total number of keywords. */
  total: number;
};

export type ListKeywords200 = {
  /** The list of keywords. */
  keywords: Keyword[];
  meta: ListKeywords200Meta;
};

export type FindKeyword200 = {
  keyword: Keyword;
};

export type GetAuthenticatedUser200OwnedCratesItem = {
  /** @deprecated */
  email_notifications: boolean;
  /** The opaque identifier of the crate. */
  id: number;
  /** The name of the crate. */
  name: string;
};

export type GetAuthenticatedUser200 = {
  /** The crates that the authenticated user owns. */
  owned_crates: GetAuthenticatedUser200OwnedCratesItem[];
  /** The authenticated user. */
  user: AuthenticatedUser;
};

export type ListCrateOwnerInvitationsForUser200 = {
  /** The list of crate owner invitations. */
  crate_owner_invitations: LegacyCrateOwnerInvitation[];
  /** The list of users referenced in the crate owner invitations. */
  users: User[];
};

export type AcceptCrateOwnerInvitationWithToken200CrateOwnerInvitation = {
  /** Whether the invitation was accepted. */
  accepted: boolean;
  /** The opaque identifier for the crate this invitation is for. */
  crate_id: number;
};

export type AcceptCrateOwnerInvitationWithToken200 = {
  crate_owner_invitation: AcceptCrateOwnerInvitationWithToken200CrateOwnerInvitation;
};

export type HandleCrateOwnerInvitation200CrateOwnerInvitation = {
  /** Whether the invitation was accepted. */
  accepted: boolean;
  /** The opaque identifier for the crate this invitation is for. */
  crate_id: number;
};

export type HandleCrateOwnerInvitation200 = {
  crate_owner_invitation: HandleCrateOwnerInvitation200CrateOwnerInvitation;
};

export type UpdateEmailNotifications200 = {
  ok: boolean;
};

export type ListApiTokens200 = {
  api_tokens: ApiToken[];
};

export type CreateApiToken200 = {
  api_token: EncodableApiTokenWithToken;
};

export type FindApiToken200 = {
  api_token: ApiToken;
};

export type RevokeApiToken200 = { [key: string]: unknown };

export type GetAuthenticatedUserUpdates200Meta = {
  /** Whether there are more versions to be loaded. */
  more: boolean;
};

export type GetAuthenticatedUserUpdates200 = {
  meta: GetAuthenticatedUserUpdates200Meta;
  /** The list of recent versions of crates that the authenticated user follows. */
  versions: Version[];
};

/**
 * Optional banner message to display on all pages.
 */
export type GetSiteMetadata200BannerMessage = string | null;

export type GetSiteMetadata200 = {
  /** Optional banner message to display on all pages. */
  banner_message?: GetSiteMetadata200BannerMessage;
  /** The SHA1 of the currently deployed commit. */
  commit: string;
  /** The SHA1 of the currently deployed commit. */
  deployed_sha: string;
  /** Whether the crates.io service is in read-only mode. */
  read_only: boolean;
};

export type GetSummary200 = {
  /** The 10 most recently updated crates. */
  just_updated: Crate[];
  /** The 10 crates with the highest total number of downloads. */
  most_downloaded: Crate[];
  /** The 10 crates with the highest number of downloads within the last 90 days. */
  most_recently_downloaded: Crate[];
  /** The 10 most recently created crates. */
  new_crates: Crate[];
  /** The total number of crates on crates.io. */
  num_crates: number;
  /** The total number of downloads across all crates. */
  num_downloads: number;
  /** The 10 most popular categories. */
  popular_categories: Category[];
  /** The 10 most popular keywords. */
  popular_keywords: Keyword[];
};

export type FindTeam200 = {
  team: Team;
};

export type ListTrustpubGithubConfigsParams = {
/**
 * Name of the crate to list Trusted Publishing configurations for.
 */
crate?: string;
/**
 * User ID to list Trusted Publishing configurations for all crates owned by the user.
 */
user_id?: number;
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

/**
 * Query string to the next page of results, if any.
 */
export type ListTrustpubGithubConfigs200MetaNextPage = string | null;

export type ListTrustpubGithubConfigs200Meta = {
  /** Query string to the next page of results, if any. */
  next_page?: ListTrustpubGithubConfigs200MetaNextPage;
  /** The total number of GitHub configs belonging to the crate. */
  total: number;
};

export type ListTrustpubGithubConfigs200 = {
  github_configs: GitHubConfig[];
  meta: ListTrustpubGithubConfigs200Meta;
};

export type CreateTrustpubGithubConfigBody = {
  github_config: NewGitHubConfig;
};

export type CreateTrustpubGithubConfig200 = {
  github_config: GitHubConfig;
};

export type ListTrustpubGitlabConfigsParams = {
/**
 * Name of the crate to list Trusted Publishing configurations for.
 */
crate?: string;
/**
 * User ID to list Trusted Publishing configurations for all crates owned by the user.
 */
user_id?: number;
/**
 * The page number to request.

This parameter is mutually exclusive with `seek` and not supported for
all requests.
 * @minimum 1
 */
page?: number;
/**
 * The number of items to request per page.
 * @minimum 1
 */
per_page?: number;
/**
 * The seek key to request.

This parameter is mutually exclusive with `page` and not supported for
all requests.

The seek key can usually be found in the `meta.next_page` field of
paginated responses.
 */
seek?: string;
};

/**
 * Query string to the next page of results, if any.
 */
export type ListTrustpubGitlabConfigs200MetaNextPage = string | null;

export type ListTrustpubGitlabConfigs200Meta = {
  /** Query string to the next page of results, if any. */
  next_page?: ListTrustpubGitlabConfigs200MetaNextPage;
  /** The total number of GitLab configs belonging to the crate. */
  total: number;
};

export type ListTrustpubGitlabConfigs200 = {
  gitlab_configs: GitLabConfig[];
  meta: ListTrustpubGitlabConfigs200Meta;
};

export type CreateTrustpubGitlabConfigBody = {
  gitlab_config: NewGitLabConfig;
};

export type CreateTrustpubGitlabConfig200 = {
  gitlab_config: GitLabConfig;
};

export type ExchangeTrustpubTokenBody = {
  jwt: string;
};

export type ExchangeTrustpubToken200 = {
  token: string;
};

export type ResendEmailVerification200 = {
  ok: boolean;
};

export type GetUserStats200 = {
  /**
   * The total number of downloads for crates owned by the user.
   * @minimum 0
   */
  total_downloads: number;
};

export type FindUser200 = {
  user: User;
};

export type UpdateUser200 = {
  ok: boolean;
};

/**
 * @summary List all crate owner invitations for a crate or user.
 */
export type listCrateOwnerInvitationsResponse200 = {
  data: ListCrateOwnerInvitations200
  status: 200
}
    
export type listCrateOwnerInvitationsResponseSuccess = (listCrateOwnerInvitationsResponse200) & {
  headers: Headers;
};
;

export type listCrateOwnerInvitationsResponse = (listCrateOwnerInvitationsResponseSuccess)

export const getListCrateOwnerInvitationsUrl = (params?: ListCrateOwnerInvitationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/private/crate_owner_invitations?${stringifiedParams}` : `/api/private/crate_owner_invitations`
}

export const listCrateOwnerInvitations = async (params?: ListCrateOwnerInvitationsParams, options?: RequestInit): Promise<listCrateOwnerInvitationsResponse> => {
  
  const res = await fetch(getListCrateOwnerInvitationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCrateOwnerInvitationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCrateOwnerInvitationsResponse
}



/**
 * @summary End the current session.
 */
export type endSessionResponse200 = {
  data: void
  status: 200
}
    
export type endSessionResponseSuccess = (endSessionResponse200) & {
  headers: Headers;
};
;

export type endSessionResponse = (endSessionResponseSuccess)

export const getEndSessionUrl = () => {


  

  return `/api/private/session`
}

export const endSession = async ( options?: RequestInit): Promise<endSessionResponse> => {
  
  const res = await fetch(getEndSessionUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: endSessionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as endSessionResponse
}



/**
 * This route is called from the GitHub API OAuth flow after the user accepted or rejected
the data access permissions. It will check the `state` parameter and then call the GitHub API
to exchange the temporary `code` for an API token. The API token is returned together with
the corresponding user information.

see <https://developer.github.com/v3/oauth/#github-redirects-back-to-your-site>

## Query Parameters

- `code` ‚Äì temporary code received from the GitHub API  **(Required)**
- `state` ‚Äì state parameter received from the GitHub API  **(Required)**
 * @summary Complete authentication flow.
 */
export type authorizeSessionResponse200 = {
  data: AuthorizeSession200
  status: 200
}
    
export type authorizeSessionResponseSuccess = (authorizeSessionResponse200) & {
  headers: Headers;
};
;

export type authorizeSessionResponse = (authorizeSessionResponseSuccess)

export const getAuthorizeSessionUrl = () => {


  

  return `/api/private/session/authorize`
}

export const authorizeSession = async ( options?: RequestInit): Promise<authorizeSessionResponse> => {
  
  const res = await fetch(getAuthorizeSessionUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: authorizeSessionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as authorizeSessionResponse
}



/**
 * This route will return an authorization URL for the GitHub OAuth flow including the crates.io
`client_id` and a randomly generated `state` secret.

see <https://developer.github.com/v3/oauth/#redirect-users-to-request-github-access>
 * @summary Begin authentication flow.
 */
export type beginSessionResponse200 = {
  data: BeginSession200
  status: 200
}
    
export type beginSessionResponseSuccess = (beginSessionResponse200) & {
  headers: Headers;
};
;

export type beginSessionResponse = (beginSessionResponseSuccess)

export const getBeginSessionUrl = () => {


  

  return `/api/private/session/begin`
}

export const beginSession = async ( options?: RequestInit): Promise<beginSessionResponse> => {
  
  const res = await fetch(getBeginSessionUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: beginSessionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as beginSessionResponse
}



/**
 * @summary List all categories.
 */
export type listCategoriesResponse200 = {
  data: ListCategories200
  status: 200
}
    
export type listCategoriesResponseSuccess = (listCategoriesResponse200) & {
  headers: Headers;
};
;

export type listCategoriesResponse = (listCategoriesResponseSuccess)

export const getListCategoriesUrl = (params?: ListCategoriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/categories?${stringifiedParams}` : `/api/v1/categories`
}

export const listCategories = async (params?: ListCategoriesParams, options?: RequestInit): Promise<listCategoriesResponse> => {
  
  const res = await fetch(getListCategoriesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCategoriesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCategoriesResponse
}



/**
 * @summary Get category metadata.
 */
export type findCategoryResponse200 = {
  data: FindCategory200
  status: 200
}
    
export type findCategoryResponseSuccess = (findCategoryResponse200) & {
  headers: Headers;
};
;

export type findCategoryResponse = (findCategoryResponseSuccess)

export const getFindCategoryUrl = (category: string,) => {


  

  return `/api/v1/categories/${category}`
}

export const findCategory = async (category: string, options?: RequestInit): Promise<findCategoryResponse> => {
  
  const res = await fetch(getFindCategoryUrl(category),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findCategoryResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findCategoryResponse
}



/**
 * @summary List all available category slugs.
 */
export type listCategorySlugsResponse200 = {
  data: ListCategorySlugs200
  status: 200
}
    
export type listCategorySlugsResponseSuccess = (listCategorySlugsResponse200) & {
  headers: Headers;
};
;

export type listCategorySlugsResponse = (listCategorySlugsResponseSuccess)

export const getListCategorySlugsUrl = () => {


  

  return `/api/v1/category_slugs`
}

export const listCategorySlugs = async ( options?: RequestInit): Promise<listCategorySlugsResponse> => {
  
  const res = await fetch(getListCategorySlugsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCategorySlugsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCategorySlugsResponse
}



/**
 * @summary Marks the email belonging to the given token as verified.
 */
export type confirmUserEmailResponse200 = {
  data: ConfirmUserEmail200
  status: 200
}
    
export type confirmUserEmailResponseSuccess = (confirmUserEmailResponse200) & {
  headers: Headers;
};
;

export type confirmUserEmailResponse = (confirmUserEmailResponseSuccess)

export const getConfirmUserEmailUrl = (emailToken: string,) => {


  

  return `/api/v1/confirm/${emailToken}`
}

export const confirmUserEmail = async (emailToken: string, options?: RequestInit): Promise<confirmUserEmailResponse> => {
  
  const res = await fetch(getConfirmUserEmailUrl(emailToken),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: confirmUserEmailResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as confirmUserEmailResponse
}



/**
 * Called in a variety of scenarios in the front end, including:
- Alphabetical listing of crates
- List of crates under a specific owner
- Listing a user's followed crates
 * @summary Returns a list of crates.
 */
export type listCratesResponse200 = {
  data: ListCrates200
  status: 200
}
    
export type listCratesResponseSuccess = (listCratesResponse200) & {
  headers: Headers;
};
;

export type listCratesResponse = (listCratesResponseSuccess)

export const getListCratesUrl = (params?: ListCratesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["ids[]"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates?${stringifiedParams}` : `/api/v1/crates`
}

export const listCrates = async (params?: ListCratesParams, options?: RequestInit): Promise<listCratesResponse> => {
  
  const res = await fetch(getListCratesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCratesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCratesResponse
}



/**
 * This endpoint works around a small limitation in `axum` and is delegating
to the `GET /api/v1/crates/{name}` endpoint internally.
 * @summary Get crate metadata (for the `new` crate).
 */
export type findNewCrateResponse200 = {
  data: FindNewCrate200
  status: 200
}
    
export type findNewCrateResponseSuccess = (findNewCrateResponse200) & {
  headers: Headers;
};
;

export type findNewCrateResponse = (findNewCrateResponseSuccess)

export const getFindNewCrateUrl = () => {


  

  return `/api/v1/crates/new`
}

export const findNewCrate = async ( options?: RequestInit): Promise<findNewCrateResponse> => {
  
  const res = await fetch(getFindNewCrateUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findNewCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findNewCrateResponse
}



/**
 * Used by `cargo publish` to publish a new crate or to publish a new version of an
existing crate.
 * @summary Publish a new crate/version.
 */
export type publishResponse200 = {
  data: Publish200
  status: 200
}
    
export type publishResponseSuccess = (publishResponse200) & {
  headers: Headers;
};
;

export type publishResponse = (publishResponseSuccess)

export const getPublishUrl = () => {


  

  return `/api/v1/crates/new`
}

export const publish = async ( options?: RequestInit): Promise<publishResponse> => {
  
  const res = await fetch(getPublishUrl(),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: publishResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as publishResponse
}



/**
 * @summary Get crate metadata.
 */
export type findCrateResponse200 = {
  data: FindCrate200
  status: 200
}
    
export type findCrateResponseSuccess = (findCrateResponse200) & {
  headers: Headers;
};
;

export type findCrateResponse = (findCrateResponseSuccess)

export const getFindCrateUrl = (name: string,
    params?: FindCrateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates/${name}?${stringifiedParams}` : `/api/v1/crates/${name}`
}

export const findCrate = async (name: string,
    params?: FindCrateParams, options?: RequestInit): Promise<findCrateResponse> => {
  
  const res = await fetch(getFindCrateUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findCrateResponse
}



/**
 * The crate is immediately deleted from the database, and with a small delay
from the git and sparse index, and the crate file storage.

The crate can only be deleted by the owner of the crate, and only if the
crate has been published for less than 72 hours, or if the crate has a
single owner, has been downloaded less than 1000 times for each month it has
been published, and is not depended upon by any other crate on crates.io.
 * @summary Delete a crate.
 */
export type deleteCrateResponse204 = {
  data: void
  status: 204
}
    
export type deleteCrateResponseSuccess = (deleteCrateResponse204) & {
  headers: Headers;
};
;

export type deleteCrateResponse = (deleteCrateResponseSuccess)

export const getDeleteCrateUrl = (name: string,
    params?: DeleteCrateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates/${name}?${stringifiedParams}` : `/api/v1/crates/${name}`
}

export const deleteCrate = async (name: string,
    params?: DeleteCrateParams, options?: RequestInit): Promise<deleteCrateResponse> => {
  
  const res = await fetch(getDeleteCrateUrl(name,params),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCrateResponse
}



/**
 * @summary Update crate settings.
 */
export type updateCrateResponse200 = {
  data: UpdateCrate200
  status: 200
}
    
export type updateCrateResponseSuccess = (updateCrateResponse200) & {
  headers: Headers;
};
;

export type updateCrateResponse = (updateCrateResponseSuccess)

export const getUpdateCrateUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}`
}

export const updateCrate = async (name: string,
    patchRequest: PatchRequest, options?: RequestInit): Promise<updateCrateResponse> => {
  
  const res = await fetch(getUpdateCrateUrl(name),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      patchRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCrateResponse
}



/**
 * This includes the per-day downloads for the last 90 days and for the
latest 5 versions plus the sum of the rest.
 * @summary Get the download counts for a crate.
 */
export type getCrateDownloadsResponse200 = {
  data: GetCrateDownloads200
  status: 200
}
    
export type getCrateDownloadsResponseSuccess = (getCrateDownloadsResponse200) & {
  headers: Headers;
};
;

export type getCrateDownloadsResponse = (getCrateDownloadsResponseSuccess)

export const getGetCrateDownloadsUrl = (name: string,
    params?: GetCrateDownloadsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates/${name}/downloads?${stringifiedParams}` : `/api/v1/crates/${name}/downloads`
}

export const getCrateDownloads = async (name: string,
    params?: GetCrateDownloadsParams, options?: RequestInit): Promise<getCrateDownloadsResponse> => {
  
  const res = await fetch(getGetCrateDownloadsUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getCrateDownloadsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getCrateDownloadsResponse
}



/**
 * @summary Follow a crate.
 */
export type followCrateResponse200 = {
  data: FollowCrate200
  status: 200
}
    
export type followCrateResponseSuccess = (followCrateResponse200) & {
  headers: Headers;
};
;

export type followCrateResponse = (followCrateResponseSuccess)

export const getFollowCrateUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/follow`
}

export const followCrate = async (name: string, options?: RequestInit): Promise<followCrateResponse> => {
  
  const res = await fetch(getFollowCrateUrl(name),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: followCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as followCrateResponse
}



/**
 * @summary Unfollow a crate.
 */
export type unfollowCrateResponse200 = {
  data: UnfollowCrate200
  status: 200
}
    
export type unfollowCrateResponseSuccess = (unfollowCrateResponse200) & {
  headers: Headers;
};
;

export type unfollowCrateResponse = (unfollowCrateResponseSuccess)

export const getUnfollowCrateUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/follow`
}

export const unfollowCrate = async (name: string, options?: RequestInit): Promise<unfollowCrateResponse> => {
  
  const res = await fetch(getUnfollowCrateUrl(name),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unfollowCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unfollowCrateResponse
}



/**
 * @summary Check if a crate is followed.
 */
export type getFollowingCrateResponse200 = {
  data: GetFollowingCrate200
  status: 200
}
    
export type getFollowingCrateResponseSuccess = (getFollowingCrateResponse200) & {
  headers: Headers;
};
;

export type getFollowingCrateResponse = (getFollowingCrateResponseSuccess)

export const getGetFollowingCrateUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/following`
}

export const getFollowingCrate = async (name: string, options?: RequestInit): Promise<getFollowingCrateResponse> => {
  
  const res = await fetch(getGetFollowingCrateUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getFollowingCrateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getFollowingCrateResponse
}



/**
 * @summary List team owners of a crate.
 */
export type getTeamOwnersResponse200 = {
  data: GetTeamOwners200
  status: 200
}
    
export type getTeamOwnersResponseSuccess = (getTeamOwnersResponse200) & {
  headers: Headers;
};
;

export type getTeamOwnersResponse = (getTeamOwnersResponseSuccess)

export const getGetTeamOwnersUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/owner_team`
}

export const getTeamOwners = async (name: string, options?: RequestInit): Promise<getTeamOwnersResponse> => {
  
  const res = await fetch(getGetTeamOwnersUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getTeamOwnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getTeamOwnersResponse
}



/**
 * @summary List user owners of a crate.
 */
export type getUserOwnersResponse200 = {
  data: GetUserOwners200
  status: 200
}
    
export type getUserOwnersResponseSuccess = (getUserOwnersResponse200) & {
  headers: Headers;
};
;

export type getUserOwnersResponse = (getUserOwnersResponseSuccess)

export const getGetUserOwnersUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/owner_user`
}

export const getUserOwners = async (name: string, options?: RequestInit): Promise<getUserOwnersResponse> => {
  
  const res = await fetch(getGetUserOwnersUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserOwnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserOwnersResponse
}



/**
 * @summary List crate owners.
 */
export type listOwnersResponse200 = {
  data: ListOwners200
  status: 200
}
    
export type listOwnersResponseSuccess = (listOwnersResponse200) & {
  headers: Headers;
};
;

export type listOwnersResponse = (listOwnersResponseSuccess)

export const getListOwnersUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/owners`
}

export const listOwners = async (name: string, options?: RequestInit): Promise<listOwnersResponse> => {
  
  const res = await fetch(getListOwnersUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listOwnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listOwnersResponse
}



/**
 * @summary Add crate owners.
 */
export type addOwnersResponse200 = {
  data: AddOwners200
  status: 200
}
    
export type addOwnersResponseSuccess = (addOwnersResponse200) & {
  headers: Headers;
};
;

export type addOwnersResponse = (addOwnersResponseSuccess)

export const getAddOwnersUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/owners`
}

export const addOwners = async (name: string,
    addOwnersBody: AddOwnersBody, options?: RequestInit): Promise<addOwnersResponse> => {
  
  const res = await fetch(getAddOwnersUrl(name),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      addOwnersBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: addOwnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as addOwnersResponse
}



/**
 * @summary Remove crate owners.
 */
export type removeOwnersResponse200 = {
  data: RemoveOwners200
  status: 200
}
    
export type removeOwnersResponseSuccess = (removeOwnersResponse200) & {
  headers: Headers;
};
;

export type removeOwnersResponse = (removeOwnersResponseSuccess)

export const getRemoveOwnersUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/owners`
}

export const removeOwners = async (name: string,
    removeOwnersBody: RemoveOwnersBody, options?: RequestInit): Promise<removeOwnersResponse> => {
  
  const res = await fetch(getRemoveOwnersUrl(name),
  {      
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      removeOwnersBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: removeOwnersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as removeOwnersResponse
}



/**
 * @summary List reverse dependencies of a crate.
 */
export type listReverseDependenciesResponse200 = {
  data: ListReverseDependencies200
  status: 200
}
    
export type listReverseDependenciesResponseSuccess = (listReverseDependenciesResponse200) & {
  headers: Headers;
};
;

export type listReverseDependenciesResponse = (listReverseDependenciesResponseSuccess)

export const getListReverseDependenciesUrl = (name: string,) => {


  

  return `/api/v1/crates/${name}/reverse_dependencies`
}

export const listReverseDependencies = async (name: string, options?: RequestInit): Promise<listReverseDependenciesResponse> => {
  
  const res = await fetch(getListReverseDependenciesUrl(name),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listReverseDependenciesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listReverseDependenciesResponse
}



/**
 * @summary List all versions of a crate.
 */
export type listVersionsResponse200 = {
  data: ListVersions200
  status: 200
}
    
export type listVersionsResponseSuccess = (listVersionsResponse200) & {
  headers: Headers;
};
;

export type listVersionsResponse = (listVersionsResponseSuccess)

export const getListVersionsUrl = (name: string,
    params?: ListVersionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["nums[]"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates/${name}/versions?${stringifiedParams}` : `/api/v1/crates/${name}/versions`
}

export const listVersions = async (name: string,
    params?: ListVersionsParams, options?: RequestInit): Promise<listVersionsResponse> => {
  
  const res = await fetch(getListVersionsUrl(name,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listVersionsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listVersionsResponse
}



/**
 * @summary Get crate version metadata.
 */
export type findVersionResponse200 = {
  data: FindVersion200
  status: 200
}
    
export type findVersionResponseSuccess = (findVersionResponse200) & {
  headers: Headers;
};
;

export type findVersionResponse = (findVersionResponseSuccess)

export const getFindVersionUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}`
}

export const findVersion = async (name: string,
    version: string, options?: RequestInit): Promise<findVersionResponse> => {
  
  const res = await fetch(getFindVersionUrl(name,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findVersionResponse
}



/**
 * This endpoint allows updating the `yanked` state of a version, including a yank message.
 * @summary Update a crate version.
 */
export type updateVersionResponse200 = {
  data: UpdateVersion200
  status: 200
}
    
export type updateVersionResponseSuccess = (updateVersionResponse200) & {
  headers: Headers;
};
;

export type updateVersionResponse = (updateVersionResponseSuccess)

export const getUpdateVersionUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}`
}

export const updateVersion = async (name: string,
    version: string, options?: RequestInit): Promise<updateVersionResponse> => {
  
  const res = await fetch(getUpdateVersionUrl(name,version),
  {      
    ...options,
    method: 'PATCH'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateVersionResponse
}



/**
 * This endpoint was deprecated by [RFC #3052](https://github.com/rust-lang/rfcs/pull/3052)
and returns an empty list for backwards compatibility reasons.
 * @deprecated
 * @summary Get crate version authors.
 */
export type getVersionAuthorsResponse200 = {
  data: void
  status: 200
}
    
export type getVersionAuthorsResponseSuccess = (getVersionAuthorsResponse200) & {
  headers: Headers;
};
;

export type getVersionAuthorsResponse = (getVersionAuthorsResponseSuccess)

export const getGetVersionAuthorsUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/authors`
}

export const getVersionAuthors = async (name: string,
    version: string, options?: RequestInit): Promise<getVersionAuthorsResponse> => {
  
  const res = await fetch(getGetVersionAuthorsUrl(name,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVersionAuthorsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVersionAuthorsResponse
}



/**
 * This information can also be obtained directly from the index.

In addition to returning cached data from the index, this returns
fields for `id`, `version_id`, and `downloads` (which appears to always
be 0)
 * @summary Get crate version dependencies.
 */
export type getVersionDependenciesResponse200 = {
  data: GetVersionDependencies200
  status: 200
}
    
export type getVersionDependenciesResponseSuccess = (getVersionDependenciesResponse200) & {
  headers: Headers;
};
;

export type getVersionDependenciesResponse = (getVersionDependenciesResponseSuccess)

export const getGetVersionDependenciesUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/dependencies`
}

export const getVersionDependencies = async (name: string,
    version: string, options?: RequestInit): Promise<getVersionDependenciesResponse> => {
  
  const res = await fetch(getGetVersionDependenciesUrl(name,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVersionDependenciesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVersionDependenciesResponse
}



/**
 * This returns a URL to the location where the crate is stored.
 * @summary Download a crate version.
 */
export type downloadVersionResponse200 = {
  data: DownloadVersion200
  status: 200
}

export type downloadVersionResponse302 = {
  data: void
  status: 302
}
    
export type downloadVersionResponseSuccess = (downloadVersionResponse200) & {
  headers: Headers;
};
export type downloadVersionResponseError = (downloadVersionResponse302) & {
  headers: Headers;
};

export type downloadVersionResponse = (downloadVersionResponseSuccess | downloadVersionResponseError)

export const getDownloadVersionUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/download`
}

export const downloadVersion = async (name: string,
    version: string, options?: RequestInit): Promise<downloadVersionResponse> => {
  
  const res = await fetch(getDownloadVersionUrl(name,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: downloadVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as downloadVersionResponse
}



/**
 * This includes the per-day downloads for the last 90 days.
 * @summary Get the download counts for a crate version.
 */
export type getVersionDownloadsResponse200 = {
  data: GetVersionDownloads200
  status: 200
}
    
export type getVersionDownloadsResponseSuccess = (getVersionDownloadsResponse200) & {
  headers: Headers;
};
;

export type getVersionDownloadsResponse = (getVersionDownloadsResponseSuccess)

export const getGetVersionDownloadsUrl = (name: string,
    version: string,
    params?: GetVersionDownloadsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/crates/${name}/${version}/downloads?${stringifiedParams}` : `/api/v1/crates/${name}/${version}/downloads`
}

export const getVersionDownloads = async (name: string,
    version: string,
    params?: GetVersionDownloadsParams, options?: RequestInit): Promise<getVersionDownloadsResponse> => {
  
  const res = await fetch(getGetVersionDownloadsUrl(name,version,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVersionDownloadsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVersionDownloadsResponse
}



/**
 * @summary Get the readme of a crate version.
 */
export type getVersionReadmeResponse200 = {
  data: GetVersionReadme200
  status: 200
}

export type getVersionReadmeResponse302 = {
  data: void
  status: 302
}
    
export type getVersionReadmeResponseSuccess = (getVersionReadmeResponse200) & {
  headers: Headers;
};
export type getVersionReadmeResponseError = (getVersionReadmeResponse302) & {
  headers: Headers;
};

export type getVersionReadmeResponse = (getVersionReadmeResponseSuccess | getVersionReadmeResponseError)

export const getGetVersionReadmeUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/readme`
}

export const getVersionReadme = async (name: string,
    version: string, options?: RequestInit): Promise<getVersionReadmeResponse> => {
  
  const res = await fetch(getGetVersionReadmeUrl(name,version),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getVersionReadmeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getVersionReadmeResponse
}



/**
 * @summary Trigger a rebuild for the crate documentation on docs.rs.
 */
export type rebuildVersionDocsResponse201 = {
  data: void
  status: 201
}
    
export type rebuildVersionDocsResponseSuccess = (rebuildVersionDocsResponse201) & {
  headers: Headers;
};
;

export type rebuildVersionDocsResponse = (rebuildVersionDocsResponseSuccess)

export const getRebuildVersionDocsUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/rebuild_docs`
}

export const rebuildVersionDocs = async (name: string,
    version: string, options?: RequestInit): Promise<rebuildVersionDocsResponse> => {
  
  const res = await fetch(getRebuildVersionDocsUrl(name,version),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: rebuildVersionDocsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as rebuildVersionDocsResponse
}



/**
 * @summary Unyank a crate version.
 */
export type unyankVersionResponse200 = {
  data: UnyankVersion200
  status: 200
}
    
export type unyankVersionResponseSuccess = (unyankVersionResponse200) & {
  headers: Headers;
};
;

export type unyankVersionResponse = (unyankVersionResponseSuccess)

export const getUnyankVersionUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/unyank`
}

export const unyankVersion = async (name: string,
    version: string, options?: RequestInit): Promise<unyankVersionResponse> => {
  
  const res = await fetch(getUnyankVersionUrl(name,version),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: unyankVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as unyankVersionResponse
}



/**
 * This does not delete a crate version, it makes the crate
version accessible only to crates that already have a
`Cargo.lock` containing this version.

Notes:

Version deletion is not implemented to avoid breaking builds,
and the goal of yanking a crate is to prevent crates
beginning to depend on the yanked crate version.
 * @summary Yank a crate version.
 */
export type yankVersionResponse200 = {
  data: YankVersion200
  status: 200
}
    
export type yankVersionResponseSuccess = (yankVersionResponse200) & {
  headers: Headers;
};
;

export type yankVersionResponse = (yankVersionResponseSuccess)

export const getYankVersionUrl = (name: string,
    version: string,) => {


  

  return `/api/v1/crates/${name}/${version}/yank`
}

export const yankVersion = async (name: string,
    version: string, options?: RequestInit): Promise<yankVersionResponse> => {
  
  const res = await fetch(getYankVersionUrl(name,version),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: yankVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as yankVersionResponse
}



/**
 * @summary List all keywords.
 */
export type listKeywordsResponse200 = {
  data: ListKeywords200
  status: 200
}
    
export type listKeywordsResponseSuccess = (listKeywordsResponse200) & {
  headers: Headers;
};
;

export type listKeywordsResponse = (listKeywordsResponseSuccess)

export const getListKeywordsUrl = (params?: ListKeywordsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/keywords?${stringifiedParams}` : `/api/v1/keywords`
}

export const listKeywords = async (params?: ListKeywordsParams, options?: RequestInit): Promise<listKeywordsResponse> => {
  
  const res = await fetch(getListKeywordsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listKeywordsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listKeywordsResponse
}



/**
 * @summary Get keyword metadata.
 */
export type findKeywordResponse200 = {
  data: FindKeyword200
  status: 200
}
    
export type findKeywordResponseSuccess = (findKeywordResponse200) & {
  headers: Headers;
};
;

export type findKeywordResponse = (findKeywordResponseSuccess)

export const getFindKeywordUrl = (keyword: string,) => {


  

  return `/api/v1/keywords/${keyword}`
}

export const findKeyword = async (keyword: string, options?: RequestInit): Promise<findKeywordResponse> => {
  
  const res = await fetch(getFindKeywordUrl(keyword),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findKeywordResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findKeywordResponse
}



/**
 * @summary Get the currently authenticated user.
 */
export type getAuthenticatedUserResponse200 = {
  data: GetAuthenticatedUser200
  status: 200
}
    
export type getAuthenticatedUserResponseSuccess = (getAuthenticatedUserResponse200) & {
  headers: Headers;
};
;

export type getAuthenticatedUserResponse = (getAuthenticatedUserResponseSuccess)

export const getGetAuthenticatedUserUrl = () => {


  

  return `/api/v1/me`
}

export const getAuthenticatedUser = async ( options?: RequestInit): Promise<getAuthenticatedUserResponse> => {
  
  const res = await fetch(getGetAuthenticatedUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAuthenticatedUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAuthenticatedUserResponse
}



/**
 * @summary List all crate owner invitations for the authenticated user.
 */
export type listCrateOwnerInvitationsForUserResponse200 = {
  data: ListCrateOwnerInvitationsForUser200
  status: 200
}
    
export type listCrateOwnerInvitationsForUserResponseSuccess = (listCrateOwnerInvitationsForUserResponse200) & {
  headers: Headers;
};
;

export type listCrateOwnerInvitationsForUserResponse = (listCrateOwnerInvitationsForUserResponseSuccess)

export const getListCrateOwnerInvitationsForUserUrl = () => {


  

  return `/api/v1/me/crate_owner_invitations`
}

export const listCrateOwnerInvitationsForUser = async ( options?: RequestInit): Promise<listCrateOwnerInvitationsForUserResponse> => {
  
  const res = await fetch(getListCrateOwnerInvitationsForUserUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCrateOwnerInvitationsForUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCrateOwnerInvitationsForUserResponse
}



/**
 * @summary Accept a crate owner invitation with a token.
 */
export type acceptCrateOwnerInvitationWithTokenResponse200 = {
  data: AcceptCrateOwnerInvitationWithToken200
  status: 200
}
    
export type acceptCrateOwnerInvitationWithTokenResponseSuccess = (acceptCrateOwnerInvitationWithTokenResponse200) & {
  headers: Headers;
};
;

export type acceptCrateOwnerInvitationWithTokenResponse = (acceptCrateOwnerInvitationWithTokenResponseSuccess)

export const getAcceptCrateOwnerInvitationWithTokenUrl = (token: string,) => {


  

  return `/api/v1/me/crate_owner_invitations/accept/${token}`
}

export const acceptCrateOwnerInvitationWithToken = async (token: string, options?: RequestInit): Promise<acceptCrateOwnerInvitationWithTokenResponse> => {
  
  const res = await fetch(getAcceptCrateOwnerInvitationWithTokenUrl(token),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: acceptCrateOwnerInvitationWithTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as acceptCrateOwnerInvitationWithTokenResponse
}



/**
 * @summary Accept or decline a crate owner invitation.
 */
export type handleCrateOwnerInvitationResponse200 = {
  data: HandleCrateOwnerInvitation200
  status: 200
}
    
export type handleCrateOwnerInvitationResponseSuccess = (handleCrateOwnerInvitationResponse200) & {
  headers: Headers;
};
;

export type handleCrateOwnerInvitationResponse = (handleCrateOwnerInvitationResponseSuccess)

export const getHandleCrateOwnerInvitationUrl = (crateId: number,) => {


  

  return `/api/v1/me/crate_owner_invitations/${crateId}`
}

export const handleCrateOwnerInvitation = async (crateId: number, options?: RequestInit): Promise<handleCrateOwnerInvitationResponse> => {
  
  const res = await fetch(getHandleCrateOwnerInvitationUrl(crateId),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: handleCrateOwnerInvitationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as handleCrateOwnerInvitationResponse
}



/**
 * This endpoint was implemented for an experimental feature that was never
fully implemented. It is now deprecated and will be removed in the future.
 * @deprecated
 * @summary Update email notification settings for the authenticated user.
 */
export type updateEmailNotificationsResponse200 = {
  data: UpdateEmailNotifications200
  status: 200
}
    
export type updateEmailNotificationsResponseSuccess = (updateEmailNotificationsResponse200) & {
  headers: Headers;
};
;

export type updateEmailNotificationsResponse = (updateEmailNotificationsResponseSuccess)

export const getUpdateEmailNotificationsUrl = () => {


  

  return `/api/v1/me/email_notifications`
}

export const updateEmailNotifications = async ( options?: RequestInit): Promise<updateEmailNotificationsResponse> => {
  
  const res = await fetch(getUpdateEmailNotificationsUrl(),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateEmailNotificationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateEmailNotificationsResponse
}



/**
 * @summary List all API tokens of the authenticated user.
 */
export type listApiTokensResponse200 = {
  data: ListApiTokens200
  status: 200
}
    
export type listApiTokensResponseSuccess = (listApiTokensResponse200) & {
  headers: Headers;
};
;

export type listApiTokensResponse = (listApiTokensResponseSuccess)

export const getListApiTokensUrl = () => {


  

  return `/api/v1/me/tokens`
}

export const listApiTokens = async ( options?: RequestInit): Promise<listApiTokensResponse> => {
  
  const res = await fetch(getListApiTokensUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listApiTokensResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listApiTokensResponse
}



/**
 * @summary Create a new API token.
 */
export type createApiTokenResponse200 = {
  data: CreateApiToken200
  status: 200
}
    
export type createApiTokenResponseSuccess = (createApiTokenResponse200) & {
  headers: Headers;
};
;

export type createApiTokenResponse = (createApiTokenResponseSuccess)

export const getCreateApiTokenUrl = () => {


  

  return `/api/v1/me/tokens`
}

export const createApiToken = async ( options?: RequestInit): Promise<createApiTokenResponse> => {
  
  const res = await fetch(getCreateApiTokenUrl(),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createApiTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createApiTokenResponse
}



/**
 * @summary Find API token by id.
 */
export type findApiTokenResponse200 = {
  data: FindApiToken200
  status: 200
}
    
export type findApiTokenResponseSuccess = (findApiTokenResponse200) & {
  headers: Headers;
};
;

export type findApiTokenResponse = (findApiTokenResponseSuccess)

export const getFindApiTokenUrl = (id: number,) => {


  

  return `/api/v1/me/tokens/${id}`
}

export const findApiToken = async (id: number, options?: RequestInit): Promise<findApiTokenResponse> => {
  
  const res = await fetch(getFindApiTokenUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findApiTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findApiTokenResponse
}



/**
 * @summary Revoke API token.
 */
export type revokeApiTokenResponse200 = {
  data: RevokeApiToken200
  status: 200
}
    
export type revokeApiTokenResponseSuccess = (revokeApiTokenResponse200) & {
  headers: Headers;
};
;

export type revokeApiTokenResponse = (revokeApiTokenResponseSuccess)

export const getRevokeApiTokenUrl = (id: number,) => {


  

  return `/api/v1/me/tokens/${id}`
}

export const revokeApiToken = async (id: number, options?: RequestInit): Promise<revokeApiTokenResponse> => {
  
  const res = await fetch(getRevokeApiTokenUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: revokeApiTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as revokeApiTokenResponse
}



/**
 * @summary List versions of crates that the authenticated user follows.
 */
export type getAuthenticatedUserUpdatesResponse200 = {
  data: GetAuthenticatedUserUpdates200
  status: 200
}
    
export type getAuthenticatedUserUpdatesResponseSuccess = (getAuthenticatedUserUpdatesResponse200) & {
  headers: Headers;
};
;

export type getAuthenticatedUserUpdatesResponse = (getAuthenticatedUserUpdatesResponseSuccess)

export const getGetAuthenticatedUserUpdatesUrl = () => {


  

  return `/api/v1/me/updates`
}

export const getAuthenticatedUserUpdates = async ( options?: RequestInit): Promise<getAuthenticatedUserUpdatesResponse> => {
  
  const res = await fetch(getGetAuthenticatedUserUpdatesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getAuthenticatedUserUpdatesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getAuthenticatedUserUpdatesResponse
}



/**
 * Returns the current deployed commit SHA1 (or `unknown`), and whether the
system is in read-only mode.
 * @summary Get crates.io metadata.
 */
export type getSiteMetadataResponse200 = {
  data: GetSiteMetadata200
  status: 200
}
    
export type getSiteMetadataResponseSuccess = (getSiteMetadataResponse200) & {
  headers: Headers;
};
;

export type getSiteMetadataResponse = (getSiteMetadataResponseSuccess)

export const getGetSiteMetadataUrl = () => {


  

  return `/api/v1/site_metadata`
}

export const getSiteMetadata = async ( options?: RequestInit): Promise<getSiteMetadataResponse> => {
  
  const res = await fetch(getGetSiteMetadataUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSiteMetadataResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSiteMetadataResponse
}



/**
 * This endpoint returns a summary of the most important data for the front
page of crates.io.
 * @summary Get front page data.
 */
export type getSummaryResponse200 = {
  data: GetSummary200
  status: 200
}
    
export type getSummaryResponseSuccess = (getSummaryResponse200) & {
  headers: Headers;
};
;

export type getSummaryResponse = (getSummaryResponseSuccess)

export const getGetSummaryUrl = () => {


  

  return `/api/v1/summary`
}

export const getSummary = async ( options?: RequestInit): Promise<getSummaryResponse> => {
  
  const res = await fetch(getGetSummaryUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getSummaryResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getSummaryResponse
}



/**
 * @summary Find team by login.
 */
export type findTeamResponse200 = {
  data: FindTeam200
  status: 200
}
    
export type findTeamResponseSuccess = (findTeamResponse200) & {
  headers: Headers;
};
;

export type findTeamResponse = (findTeamResponseSuccess)

export const getFindTeamUrl = (team: string,) => {


  

  return `/api/v1/teams/${team}`
}

export const findTeam = async (team: string, options?: RequestInit): Promise<findTeamResponse> => {
  
  const res = await fetch(getFindTeamUrl(team),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findTeamResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findTeamResponse
}



/**
 * This endpoint revokes the API token that is used to authenticate
the request.
 * @summary Revoke the current API token.
 */
export type revokeCurrentApiTokenResponse204 = {
  data: void
  status: 204
}
    
export type revokeCurrentApiTokenResponseSuccess = (revokeCurrentApiTokenResponse204) & {
  headers: Headers;
};
;

export type revokeCurrentApiTokenResponse = (revokeCurrentApiTokenResponseSuccess)

export const getRevokeCurrentApiTokenUrl = () => {


  

  return `/api/v1/tokens/current`
}

export const revokeCurrentApiToken = async ( options?: RequestInit): Promise<revokeCurrentApiTokenResponse> => {
  
  const res = await fetch(getRevokeCurrentApiTokenUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: revokeCurrentApiTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as revokeCurrentApiTokenResponse
}



/**
 * @summary List Trusted Publishing configurations for GitHub Actions.
 */
export type listTrustpubGithubConfigsResponse200 = {
  data: ListTrustpubGithubConfigs200
  status: 200
}
    
export type listTrustpubGithubConfigsResponseSuccess = (listTrustpubGithubConfigsResponse200) & {
  headers: Headers;
};
;

export type listTrustpubGithubConfigsResponse = (listTrustpubGithubConfigsResponseSuccess)

export const getListTrustpubGithubConfigsUrl = (params?: ListTrustpubGithubConfigsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/trusted_publishing/github_configs?${stringifiedParams}` : `/api/v1/trusted_publishing/github_configs`
}

export const listTrustpubGithubConfigs = async (params?: ListTrustpubGithubConfigsParams, options?: RequestInit): Promise<listTrustpubGithubConfigsResponse> => {
  
  const res = await fetch(getListTrustpubGithubConfigsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listTrustpubGithubConfigsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listTrustpubGithubConfigsResponse
}



/**
 * @summary Create a new Trusted Publishing configuration for GitHub Actions.
 */
export type createTrustpubGithubConfigResponse200 = {
  data: CreateTrustpubGithubConfig200
  status: 200
}
    
export type createTrustpubGithubConfigResponseSuccess = (createTrustpubGithubConfigResponse200) & {
  headers: Headers;
};
;

export type createTrustpubGithubConfigResponse = (createTrustpubGithubConfigResponseSuccess)

export const getCreateTrustpubGithubConfigUrl = () => {


  

  return `/api/v1/trusted_publishing/github_configs`
}

export const createTrustpubGithubConfig = async (createTrustpubGithubConfigBody: CreateTrustpubGithubConfigBody, options?: RequestInit): Promise<createTrustpubGithubConfigResponse> => {
  
  const res = await fetch(getCreateTrustpubGithubConfigUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTrustpubGithubConfigBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createTrustpubGithubConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createTrustpubGithubConfigResponse
}



/**
 * @summary Delete Trusted Publishing configuration for GitHub Actions.
 */
export type deleteTrustpubGithubConfigResponse204 = {
  data: void
  status: 204
}
    
export type deleteTrustpubGithubConfigResponseSuccess = (deleteTrustpubGithubConfigResponse204) & {
  headers: Headers;
};
;

export type deleteTrustpubGithubConfigResponse = (deleteTrustpubGithubConfigResponseSuccess)

export const getDeleteTrustpubGithubConfigUrl = (id: number,) => {


  

  return `/api/v1/trusted_publishing/github_configs/${id}`
}

export const deleteTrustpubGithubConfig = async (id: number, options?: RequestInit): Promise<deleteTrustpubGithubConfigResponse> => {
  
  const res = await fetch(getDeleteTrustpubGithubConfigUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteTrustpubGithubConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteTrustpubGithubConfigResponse
}



/**
 * @summary List Trusted Publishing configurations for GitLab CI/CD.
 */
export type listTrustpubGitlabConfigsResponse200 = {
  data: ListTrustpubGitlabConfigs200
  status: 200
}
    
export type listTrustpubGitlabConfigsResponseSuccess = (listTrustpubGitlabConfigsResponse200) & {
  headers: Headers;
};
;

export type listTrustpubGitlabConfigsResponse = (listTrustpubGitlabConfigsResponseSuccess)

export const getListTrustpubGitlabConfigsUrl = (params?: ListTrustpubGitlabConfigsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/trusted_publishing/gitlab_configs?${stringifiedParams}` : `/api/v1/trusted_publishing/gitlab_configs`
}

export const listTrustpubGitlabConfigs = async (params?: ListTrustpubGitlabConfigsParams, options?: RequestInit): Promise<listTrustpubGitlabConfigsResponse> => {
  
  const res = await fetch(getListTrustpubGitlabConfigsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listTrustpubGitlabConfigsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listTrustpubGitlabConfigsResponse
}



export type createTrustpubGitlabConfigResponse200 = {
  data: CreateTrustpubGitlabConfig200
  status: 200
}
    
export type createTrustpubGitlabConfigResponseSuccess = (createTrustpubGitlabConfigResponse200) & {
  headers: Headers;
};
;

export type createTrustpubGitlabConfigResponse = (createTrustpubGitlabConfigResponseSuccess)

export const getCreateTrustpubGitlabConfigUrl = () => {


  

  return `/api/v1/trusted_publishing/gitlab_configs`
}

export const createTrustpubGitlabConfig = async (createTrustpubGitlabConfigBody: CreateTrustpubGitlabConfigBody, options?: RequestInit): Promise<createTrustpubGitlabConfigResponse> => {
  
  const res = await fetch(getCreateTrustpubGitlabConfigUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createTrustpubGitlabConfigBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createTrustpubGitlabConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createTrustpubGitlabConfigResponse
}



/**
 * @summary Delete Trusted Publishing configuration for GitLab CI/CD.
 */
export type deleteTrustpubGitlabConfigResponse204 = {
  data: void
  status: 204
}
    
export type deleteTrustpubGitlabConfigResponseSuccess = (deleteTrustpubGitlabConfigResponse204) & {
  headers: Headers;
};
;

export type deleteTrustpubGitlabConfigResponse = (deleteTrustpubGitlabConfigResponseSuccess)

export const getDeleteTrustpubGitlabConfigUrl = (id: number,) => {


  

  return `/api/v1/trusted_publishing/gitlab_configs/${id}`
}

export const deleteTrustpubGitlabConfig = async (id: number, options?: RequestInit): Promise<deleteTrustpubGitlabConfigResponse> => {
  
  const res = await fetch(getDeleteTrustpubGitlabConfigUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteTrustpubGitlabConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteTrustpubGitlabConfigResponse
}



/**
 * @summary Exchange an OIDC token for a temporary access token.
 */
export type exchangeTrustpubTokenResponse200 = {
  data: ExchangeTrustpubToken200
  status: 200
}
    
export type exchangeTrustpubTokenResponseSuccess = (exchangeTrustpubTokenResponse200) & {
  headers: Headers;
};
;

export type exchangeTrustpubTokenResponse = (exchangeTrustpubTokenResponseSuccess)

export const getExchangeTrustpubTokenUrl = () => {


  

  return `/api/v1/trusted_publishing/tokens`
}

export const exchangeTrustpubToken = async (exchangeTrustpubTokenBody: ExchangeTrustpubTokenBody, options?: RequestInit): Promise<exchangeTrustpubTokenResponse> => {
  
  const res = await fetch(getExchangeTrustpubTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      exchangeTrustpubTokenBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: exchangeTrustpubTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as exchangeTrustpubTokenResponse
}



/**
 * The access token is expected to be passed in the `Authorization` header
as a `Bearer` token, similar to how it is used in the publish endpoint.
 * @summary Revoke a temporary access token.
 */
export type revokeTrustpubTokenResponse204 = {
  data: void
  status: 204
}
    
export type revokeTrustpubTokenResponseSuccess = (revokeTrustpubTokenResponse204) & {
  headers: Headers;
};
;

export type revokeTrustpubTokenResponse = (revokeTrustpubTokenResponseSuccess)

export const getRevokeTrustpubTokenUrl = () => {


  

  return `/api/v1/trusted_publishing/tokens`
}

export const revokeTrustpubToken = async ( options?: RequestInit): Promise<revokeTrustpubTokenResponse> => {
  
  const res = await fetch(getRevokeTrustpubTokenUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: revokeTrustpubTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as revokeTrustpubTokenResponse
}



/**
 * @summary Regenerate and send an email verification token.
 */
export type resendEmailVerificationResponse200 = {
  data: ResendEmailVerification200
  status: 200
}
    
export type resendEmailVerificationResponseSuccess = (resendEmailVerificationResponse200) & {
  headers: Headers;
};
;

export type resendEmailVerificationResponse = (resendEmailVerificationResponseSuccess)

export const getResendEmailVerificationUrl = (id: number,) => {


  

  return `/api/v1/users/${id}/resend`
}

export const resendEmailVerification = async (id: number, options?: RequestInit): Promise<resendEmailVerificationResponse> => {
  
  const res = await fetch(getResendEmailVerificationUrl(id),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: resendEmailVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as resendEmailVerificationResponse
}



/**
 * This currently only returns the total number of downloads for crates owned
by the user.
 * @summary Get user stats.
 */
export type getUserStatsResponse200 = {
  data: GetUserStats200
  status: 200
}
    
export type getUserStatsResponseSuccess = (getUserStatsResponse200) & {
  headers: Headers;
};
;

export type getUserStatsResponse = (getUserStatsResponseSuccess)

export const getGetUserStatsUrl = (id: number,) => {


  

  return `/api/v1/users/${id}/stats`
}

export const getUserStats = async (id: number, options?: RequestInit): Promise<getUserStatsResponse> => {
  
  const res = await fetch(getGetUserStatsUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: getUserStatsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as getUserStatsResponse
}



/**
 * @summary Find user by login.
 */
export type findUserResponse200 = {
  data: FindUser200
  status: 200
}
    
export type findUserResponseSuccess = (findUserResponse200) & {
  headers: Headers;
};
;

export type findUserResponse = (findUserResponseSuccess)

export const getFindUserUrl = (user: string,) => {


  

  return `/api/v1/users/${user}`
}

export const findUser = async (user: string, options?: RequestInit): Promise<findUserResponse> => {
  
  const res = await fetch(getFindUserUrl(user),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: findUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as findUserResponse
}



/**
 * This endpoint allows users to update their email address and publish notifications settings.

The `id` parameter needs to match the ID of the currently authenticated user.
 * @summary Update user settings.
 */
export type updateUserResponse200 = {
  data: UpdateUser200
  status: 200
}
    
export type updateUserResponseSuccess = (updateUserResponse200) & {
  headers: Headers;
};
;

export type updateUserResponse = (updateUserResponseSuccess)

export const getUpdateUserUrl = (user: number,) => {


  

  return `/api/v1/users/${user}`
}

export const updateUser = async (user: number, options?: RequestInit): Promise<updateUserResponse> => {
  
  const res = await fetch(getUpdateUserUrl(user),
  {      
    ...options,
    method: 'PUT'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserResponse
}
