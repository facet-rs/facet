//! Generate benchmark code from benchmarks.kdl definitions.
//!
//! This ensures every benchmark has BOTH divan (wall-clock) AND gungraun (instruction count) versions
//! for ALL 5 targets (facet_format_jit, facet_format_json, facet_json, facet_json_cranelift, serde_json).

use benchmark_defs::{BenchmarkDef, TypeDef};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    let args: Vec<String> = env::args().skip(1).collect();

    // Find workspace root by looking for Cargo.toml with [workspace]
    let workspace_root = find_workspace_root().unwrap_or_else(|| {
        eprintln!("Could not find workspace root");
        std::process::exit(1);
    });

    let kdl_path = args
        .first()
        .map(PathBuf::from)
        .unwrap_or_else(|| workspace_root.join("facet-json/benches/benchmarks.kdl"));

    let divan_path = workspace_root.join("facet-json/benches/unified_benchmarks_divan.rs");
    let gungraun_path = workspace_root.join("facet-json/benches/unified_benchmarks_gungraun.rs");
    let tests_path = workspace_root.join("facet-json/tests/generated_benchmark_tests.rs");

    match generate_benchmarks(
        &kdl_path,
        &divan_path,
        &gungraun_path,
        &tests_path,
        &workspace_root,
    ) {
        Ok(()) => {
            println!("\nðŸŽ‰ Success!");
            println!("Run benchmarks with:");
            println!(
                "   cargo bench --bench unified_benchmarks_divan --features cranelift --features jit"
            );
            println!(
                "   cargo bench --bench unified_benchmarks_gungraun --features cranelift --features jit"
            );
            println!("Run tests (for debugging with valgrind):");
            println!(
                "   cargo nextest run -p facet-json generated_benchmark_tests --features cranelift --features jit"
            );
            println!(
                "   valgrind cargo test -p facet-json generated_benchmark_tests --features jit -- --test-threads=1"
            );
        }
        Err(e) => {
            eprintln!("âŒ Error generating benchmarks: {}", e);
            std::process::exit(1);
        }
    }
}

fn find_workspace_root() -> Option<PathBuf> {
    let mut current = env::current_dir().ok()?;
    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists()
            && let Ok(content) = fs::read_to_string(&cargo_toml)
            && content.contains("[workspace]")
        {
            return Some(current);
        }
        if !current.pop() {
            return None;
        }
    }
}

fn generate_benchmarks(
    kdl_path: &Path,
    divan_output_path: &Path,
    gungraun_output_path: &Path,
    tests_output_path: &Path,
    workspace_root: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    println!(
        "ðŸ“– Reading benchmark definitions from {}",
        kdl_path.display()
    );

    let file = match benchmark_defs::parse_benchmarks(kdl_path) {
        Ok(f) => f,
        Err(e) => {
            eprintln!("âŒ Failed to parse KDL:");
            eprintln!("{:?}", e);
            return Err(e);
        }
    };

    let benchmarks = file.benchmarks;
    let type_defs = file.type_defs;

    println!("   Found {} benchmarks", benchmarks.len());
    println!("   Found {} type definitions", type_defs.len());

    // Generate DIVAN benchmarks
    let divan_output = generate_divan_benchmarks(&benchmarks, &type_defs, workspace_root)?;
    println!(
        "âœï¸  Writing divan benchmarks to {}",
        divan_output_path.display()
    );
    fs::write(divan_output_path, divan_output)?;

    // Generate GUNGRAUN benchmarks
    let gungraun_output = generate_gungraun_benchmarks(&benchmarks, &type_defs, workspace_root)?;
    println!(
        "âœï¸  Writing gungraun benchmarks to {}",
        gungraun_output_path.display()
    );
    fs::write(gungraun_output_path, gungraun_output)?;

    // Generate TESTS (for valgrind debugging)
    let tests_output = generate_tests(&benchmarks, &type_defs, workspace_root)?;
    println!("âœï¸  Writing tests to {}", tests_output_path.display());
    fs::write(tests_output_path, tests_output)?;

    println!(
        "âœ… Generated {} benchmarks Ã— 5 targets Ã— 2 harnesses = {} total benchmark functions!",
        benchmarks.len(),
        benchmarks.len() * 5 * 2
    );
    println!(
        "âœ… Generated {} test modules for valgrind debugging!",
        benchmarks.len()
    );

    Ok(())
}

fn generate_divan_benchmarks(
    benchmarks: &[BenchmarkDef],
    type_defs: &[TypeDef],
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by benchmark-generator\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str(
        "//! This file ensures parity: every benchmark has BOTH divan AND gungraun versions\n",
    );
    output.push_str("//! for ALL 5 targets.\n\n");
    output.push_str("#![allow(clippy::explicit_auto_deref)]\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("use facet_format_json::JsonParser;\n");
    output.push_str("use divan::Bencher;\n");
    output.push_str("use std::hint::black_box;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate only DIVAN benchmark modules
    for bench_def in benchmarks {
        output.push_str(&generate_divan_benchmark_module(bench_def, workspace_root)?);
    }

    // Entry point for divan harness
    output.push_str("fn main() {\n");
    output.push_str("    divan::main();\n");
    output.push_str("}\n");

    Ok(output)
}

fn generate_gungraun_benchmarks(
    benchmarks: &[BenchmarkDef],
    type_defs: &[TypeDef],
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by benchmark-generator\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str("//! Gungraun benchmarks (instruction counts)\n\n");
    output.push_str("#![allow(clippy::explicit_auto_deref)]\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("use facet_format_json::JsonParser;\n");
    output.push_str("use std::hint::black_box;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate only GUNGRAUN benchmark modules
    for bench_def in benchmarks {
        output.push_str(&generate_gungraun_benchmark_module(
            bench_def,
            workspace_root,
        )?);
    }

    // Generate gungraun groups
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Gungraun Benchmark Groups\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    // Re-export gungraun benchmarks at module level for macro compatibility
    output.push_str("// Re-export gungraun DESERIALIZE benchmarks\n");
    for bench_def in benchmarks {
        let skip_jit = bench_def.category == "realistic";
        if !skip_jit {
            output.push_str(&format!(
                "use {}::gungraun_{}_facet_format_jit_deserialize;\n",
                bench_def.name, bench_def.name
            ));
        }
        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "use {}::gungraun_{}_{}_deserialize;\n",
                bench_def.name, bench_def.name, target
            ));
        }
        output.push_str(&format!(
            "#[cfg(feature = \"cranelift\")]\nuse {}::gungraun_{}_facet_json_cranelift_deserialize;\n",
            bench_def.name, bench_def.name
        ));
    }
    output.push('\n');

    output.push_str("// Re-export gungraun SERIALIZE benchmarks\n");
    for bench_def in benchmarks {
        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "use {}::gungraun_{}_{}_serialize;\n",
                bench_def.name, bench_def.name, target
            ));
        }
    }
    output.push('\n');

    // Deserialize groups
    for bench_def in benchmarks {
        let skip_jit = bench_def.category == "realistic";
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_deser;\n    benchmarks =\n",
            bench_def.name
        ));

        if !skip_jit {
            output.push_str(&format!(
                "        gungraun_{}_facet_format_jit_deserialize,\n",
                bench_def.name
            ));
        }
        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "        gungraun_{}_{}_deserialize,\n",
                bench_def.name, target
            ));
        }

        output.push_str(");\n\n");

        // Cranelift deserialize group
        output.push_str("#[cfg(feature = \"cranelift\")]\n");
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_cranelift_deser;\n    benchmarks = gungraun_{}_facet_json_cranelift_deserialize\n);\n\n",
            bench_def.name, bench_def.name
        ));
    }

    // Serialize groups
    for bench_def in benchmarks {
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_ser;\n    benchmarks =\n",
            bench_def.name
        ));

        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "        gungraun_{}_{}_serialize,\n",
                bench_def.name, target
            ));
        }

        output.push_str(");\n\n");
    }

    // Main gungraun entry point
    output.push_str("// Gungraun main\n");
    output.push_str("#[cfg(not(feature = \"cranelift\"))]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!(
            "        {}_deser,\n        {}_ser",
            bench_def.name, bench_def.name
        ));
    }
    output.push_str("\n);\n\n");

    output.push_str("#[cfg(feature = \"cranelift\")]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!(
            "        {}_deser,\n        {}_cranelift_deser,\n        {}_ser",
            bench_def.name, bench_def.name, bench_def.name
        ));
    }
    output.push_str("\n);\n");

    Ok(output)
}

fn generate_divan_benchmark_module(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// BENCHMARK: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod {} {{\n", bench_def.name));
    output.push_str("    use super::*;\n");
    output.push_str("    use std::sync::LazyLock;\n\n");

    let is_brotli = bench_def.json_brotli.is_some();

    if is_brotli {
        // Brotli-compressed data: use include_bytes! + LazyLock for decompression
        let brotli_path = bench_def.json_brotli.as_ref().unwrap();
        output.push_str(&format!(
            "    static COMPRESSED: &[u8] = include_bytes!(\"../../tools/benchmark-generator/{}\");\n\n",
            brotli_path.path
        ));
        output.push_str("    static JSON: LazyLock<Vec<u8>> = LazyLock::new(|| {\n");
        output.push_str("        let mut decompressed = Vec::new();\n");
        output.push_str("        brotli::BrotliDecompress(&mut std::io::Cursor::new(COMPRESSED), &mut decompressed).unwrap();\n");
        output.push_str("        decompressed\n");
        output.push_str("    });\n\n");
    } else {
        // Inline or file-based JSON: embed directly
        let json_content = get_json_content(bench_def, workspace_root)?;
        output.push_str(&format!(
            "    static JSON: &[u8] = br#\"{}\"#;\n\n",
            json_content
        ));
    }

    // Pre-deserialize data for serialization benchmarks
    let json_ref_for_deser = if is_brotli { "&*JSON" } else { "JSON" };
    output.push_str(&format!(
        "    static DATA: LazyLock<{}> = LazyLock::new(|| serde_json::from_slice({}).unwrap());\n\n",
        bench_def.type_name, json_ref_for_deser
    ));

    // Skip JIT for realistic benchmarks - JIT doesn't support complex nested types
    let skip_jit = bench_def.category == "realistic";

    // DIVAN DESERIALIZE benchmarks
    output.push_str("    // ===== DIVAN DESERIALIZE =====\n\n");

    let targets = vec![
        ("facet_format_jit", true, false),
        ("facet_format_json", false, false),
        ("facet_json", false, false),
        ("facet_json_cranelift", false, true),
        ("serde_json", false, false),
    ];

    for (target_name, needs_parser, is_cranelift) in &targets {
        // Skip JIT benchmark for realistic category
        if *needs_parser && skip_jit {
            continue;
        }
        if *is_cranelift {
            output.push_str("    #[cfg(feature = \"cranelift\")]\n");
        }

        output.push_str("    #[divan::bench]\n");
        output.push_str(&format!(
            "    fn {}_deserialize(bencher: Bencher) {{\n",
            target_name
        ));

        // Get JSON reference (different for brotli vs inline)
        if is_brotli {
            output.push_str("        let json = &*JSON;\n");
        }

        if *is_cranelift {
            if is_brotli {
                output.push_str(
                    "        let json_str = unsafe { std::str::from_utf8_unchecked(json) };\n",
                );
            } else {
                output.push_str(
                    "        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n",
                );
            }
        }

        output.push_str("        bencher.bench(|| {\n");

        let json_ref = if is_brotli { "json.as_slice()" } else { "JSON" };

        if *needs_parser {
            output.push_str(&format!(
                "            black_box(format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new(black_box({}))).unwrap())\n",
                bench_def.type_name, json_ref
            ));
        } else if *is_cranelift {
            output.push_str(&format!(
                "            black_box(facet_json::cranelift::from_str_with_fallback::<{}>(black_box(json_str)).unwrap())\n",
                bench_def.type_name
            ));
        } else {
            let deser_fn = match *target_name {
                "facet_format_json" => "facet_format_json::from_slice",
                "facet_json" => "facet_json::from_slice",
                "serde_json" => "serde_json::from_slice",
                _ => unreachable!(),
            };
            output.push_str(&format!(
                "            black_box({}::<{}>(black_box({})).unwrap())\n",
                deser_fn, bench_def.type_name, json_ref
            ));
        }

        output.push_str("        });\n");
        output.push_str("    }\n\n");
    }

    // DIVAN SERIALIZE benchmarks
    output.push_str("    // ===== DIVAN SERIALIZE =====\n\n");

    // Serialization targets (no JIT serialize yet, no cranelift serialize)
    // facet_json::to_string returns String directly, others return Result
    let serialize_targets = vec![
        ("facet_format_json", "facet_format_json::to_string", true), // returns Result
        ("facet_json", "facet_json::to_string", false),              // returns String
        ("serde_json", "serde_json::to_string", true),               // returns Result
    ];

    for (target_name, ser_fn, needs_unwrap) in &serialize_targets {
        output.push_str("    #[divan::bench]\n");
        output.push_str(&format!(
            "    fn {}_serialize(bencher: Bencher) {{\n",
            target_name
        ));
        output.push_str("        let data = &*DATA;\n");
        output.push_str("        bencher.bench(|| {\n");
        if *needs_unwrap {
            output.push_str(&format!(
                "            black_box({}(black_box(data)).unwrap())\n",
                ser_fn
            ));
        } else {
            output.push_str(&format!(
                "            black_box({}(black_box(data)))\n",
                ser_fn
            ));
        }
        output.push_str("        });\n");
        output.push_str("    }\n\n");
    }

    output.push_str("}\n\n");
    Ok(output)
}

fn generate_gungraun_benchmark_module(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// BENCHMARK: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod {} {{\n", bench_def.name));
    output.push_str("    use super::*;\n");
    output.push_str("    use std::sync::LazyLock;\n\n");

    let is_brotli = bench_def.json_brotli.is_some();

    if is_brotli {
        // Brotli-compressed data: use include_bytes! + LazyLock for decompression
        let brotli_path = bench_def.json_brotli.as_ref().unwrap();
        output.push_str(&format!(
            "    static COMPRESSED: &[u8] = include_bytes!(\"../../tools/benchmark-generator/{}\");\n\n",
            brotli_path.path
        ));
        output.push_str("    static JSON: LazyLock<Vec<u8>> = LazyLock::new(|| {\n");
        output.push_str("        let mut decompressed = Vec::new();\n");
        output.push_str("        brotli::BrotliDecompress(&mut std::io::Cursor::new(COMPRESSED), &mut decompressed).unwrap();\n");
        output.push_str("        decompressed\n");
        output.push_str("    });\n\n");
    } else {
        // Inline or file-based JSON: embed directly
        let json_content = get_json_content(bench_def, workspace_root)?;
        output.push_str(&format!(
            "    static JSON: &[u8] = br#\"{}\"#;\n\n",
            json_content
        ));
    }

    // Pre-deserialize data for serialization benchmarks
    let json_ref_for_deser = if is_brotli { "&*JSON" } else { "JSON" };
    output.push_str(&format!(
        "    static DATA: LazyLock<{}> = LazyLock::new(|| serde_json::from_slice({}).unwrap());\n\n",
        bench_def.type_name, json_ref_for_deser
    ));

    // Skip JIT for realistic benchmarks - JIT doesn't support complex nested types
    let skip_jit = bench_def.category == "realistic";

    // GUNGRAUN DESERIALIZE benchmarks
    output.push_str("    // ===== GUNGRAUN DESERIALIZE =====\n\n");

    // JIT warmup - different for brotli vs inline
    if is_brotli && !skip_jit {
        output.push_str("    fn setup_jit() -> &'static [u8] {\n");
        output.push_str(
            "        let json: &'static [u8] = Box::leak(JSON.clone().into_boxed_slice());\n",
        );
        output.push_str(&format!(
            "        let _ = format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new(json));\n",
            bench_def.type_name
        ));
        output.push_str("        json\n");
        output.push_str("    }\n\n");
    } else if !skip_jit {
        output.push_str("    fn setup_jit() -> &'static [u8] {\n");
        output.push_str(&format!(
            "        let _ = format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new(JSON));\n",
            bench_def.type_name
        ));
        output.push_str("        JSON\n");
        output.push_str("    }\n\n");
    }

    // JIT benchmark (skip for realistic)
    if !skip_jit {
        output.push_str("    #[gungraun::library_benchmark]\n");
        output.push_str("    #[bench::cached(setup = setup_jit)]\n");
        output.push_str(&format!(
            "    pub fn gungraun_{}_facet_format_jit_deserialize(json: &[u8]) -> {} {{\n",
            bench_def.name, bench_def.type_name
        ));
        output.push_str("        let parser = JsonParser::new(black_box(json));\n");
        output.push_str(&format!(
            "        black_box(format_jit::deserialize_with_fallback::<{}, _>(parser).unwrap())\n",
            bench_def.type_name
        ));
        output.push_str("    }\n\n");
    }

    // Other gungraun deserialize targets
    let json_ref = if is_brotli { "&*JSON" } else { "JSON" };
    for target in &["facet_format_json", "facet_json", "serde_json"] {
        output.push_str("    #[gungraun::library_benchmark]\n");
        output.push_str(&format!(
            "    pub fn gungraun_{}_{}_deserialize() -> {} {{\n",
            bench_def.name, target, bench_def.type_name
        ));
        output.push_str(&format!(
            "        black_box({}::from_slice::<{}>(black_box({})).unwrap())\n",
            target, bench_def.type_name, json_ref
        ));
        output.push_str("    }\n\n");
    }

    // Cranelift gungraun with warmup
    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    if is_brotli {
        output.push_str("    fn setup_cranelift() -> &'static str {\n");
        output.push_str(
            "        let json: &'static [u8] = Box::leak(JSON.clone().into_boxed_slice());\n",
        );
        output.push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(json) };\n");
        output.push_str(&format!(
            "        let _ = facet_json::cranelift::from_str_with_fallback::<{}>(json_str);\n",
            bench_def.type_name
        ));
        output.push_str("        json_str\n");
        output.push_str("    }\n\n");
    } else {
        output.push_str("    fn setup_cranelift() -> &'static str {\n");
        output.push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n");
        output.push_str(&format!(
            "        let _ = facet_json::cranelift::from_str_with_fallback::<{}>(json_str);\n",
            bench_def.type_name
        ));
        output.push_str("        json_str\n");
        output.push_str("    }\n\n");
    }

    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    #[gungraun::library_benchmark]\n");
    output.push_str("    #[bench::cached(setup = setup_cranelift)]\n");
    output.push_str(&format!(
        "    pub fn gungraun_{}_facet_json_cranelift_deserialize(json: &str) -> {} {{\n",
        bench_def.name, bench_def.type_name
    ));
    output.push_str(&format!(
        "        black_box(facet_json::cranelift::from_str_with_fallback::<{}>(black_box(json)).unwrap())\n",
        bench_def.type_name
    ));
    output.push_str("    }\n\n");

    // GUNGRAUN SERIALIZE benchmarks
    output.push_str("    // ===== GUNGRAUN SERIALIZE =====\n\n");

    // Setup for serialization - get static reference to data
    output.push_str(&format!(
        "    fn setup_serialize() -> &'static {} {{\n",
        bench_def.type_name
    ));
    output.push_str("        &*DATA\n");
    output.push_str("    }\n\n");

    // Serialize benchmarks - facet_json::to_string returns String directly, others return Result
    let serialize_targets = [
        ("facet_format_json", "facet_format_json::to_string", true), // returns Result
        ("facet_json", "facet_json::to_string", false),              // returns String
        ("serde_json", "serde_json::to_string", true),               // returns Result
    ];
    for (target, ser_fn, needs_unwrap) in &serialize_targets {
        output.push_str("    #[gungraun::library_benchmark]\n");
        output.push_str("    #[bench::cached(setup = setup_serialize)]\n");
        output.push_str(&format!(
            "    pub fn gungraun_{}_{}_serialize(data: &{}) -> String {{\n",
            bench_def.name, target, bench_def.type_name
        ));
        if *needs_unwrap {
            output.push_str(&format!(
                "        black_box({}(black_box(data)).unwrap())\n",
                ser_fn
            ));
        } else {
            output.push_str(&format!("        black_box({}(black_box(data)))\n", ser_fn));
        }
        output.push_str("    }\n\n");
    }

    output.push_str("}\n\n");
    Ok(output)
}

fn generate_tests(
    benchmarks: &[BenchmarkDef],
    type_defs: &[TypeDef],
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by benchmark-generator\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str(
        "//! These tests mirror the benchmarks and can be run under valgrind for debugging.\n",
    );
    output.push_str("//! Run with: valgrind cargo test -p facet-json generated_benchmark_tests --features jit -- --test-threads=1\n\n");
    output.push_str("#![allow(clippy::explicit_auto_deref)]\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("#[cfg(feature = \"jit\")]\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("#[cfg(feature = \"jit\")]\n");
    output.push_str("use facet_format_json::JsonParser;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate test modules
    for bench_def in benchmarks {
        output.push_str(&generate_test_module(bench_def, workspace_root)?);
    }

    Ok(output)
}

fn generate_test_module(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// TESTS: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod test_{} {{\n", bench_def.name));
    output.push_str("    use super::*;\n");
    output.push_str("    use std::sync::LazyLock;\n\n");

    let is_brotli = bench_def.json_brotli.is_some();

    if is_brotli {
        let brotli_path = bench_def.json_brotli.as_ref().unwrap();
        output.push_str(&format!(
            "    static COMPRESSED: &[u8] = include_bytes!(\"../../tools/benchmark-generator/{}\");\n\n",
            brotli_path.path
        ));
        output.push_str("    static JSON: LazyLock<Vec<u8>> = LazyLock::new(|| {\n");
        output.push_str("        let mut decompressed = Vec::new();\n");
        output.push_str("        brotli::BrotliDecompress(&mut std::io::Cursor::new(COMPRESSED), &mut decompressed).unwrap();\n");
        output.push_str("        decompressed\n");
        output.push_str("    });\n\n");
    } else {
        let json_content = get_json_content(bench_def, workspace_root)?;
        output.push_str(&format!(
            "    static JSON: &[u8] = br#\"{}\"#;\n\n",
            json_content
        ));
    }

    // Pre-deserialize data for serialization tests
    let json_ref_for_deser = if is_brotli { "&*JSON" } else { "JSON" };
    output.push_str(&format!(
        "    static DATA: LazyLock<{}> = LazyLock::new(|| serde_json::from_slice({}).unwrap());\n\n",
        bench_def.type_name, json_ref_for_deser
    ));

    let skip_jit = bench_def.category == "realistic";
    let json_ref = if is_brotli { "&*JSON" } else { "JSON" };

    // DESERIALIZE tests
    output.push_str("    // ===== DESERIALIZE TESTS =====\n\n");

    // JIT deserialize test (skip for realistic)
    if !skip_jit {
        output.push_str("    #[cfg(feature = \"jit\")]\n");
        output.push_str("    #[test]\n");
        output.push_str("    fn test_facet_format_jit_deserialize() {\n");
        output.push_str(&format!(
            "        let result = format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new({}));\n",
            bench_def.type_name, json_ref
        ));
        output.push_str(
            "        assert!(result.is_ok(), \"JIT deserialize failed: {:?}\", result.err());\n",
        );
        output.push_str("    }\n\n");
    }

    // facet_format_json test
    output.push_str("    #[test]\n");
    output.push_str("    fn test_facet_format_json_deserialize() {\n");
    output.push_str(&format!(
        "        let result = facet_format_json::from_slice::<{}>({});\n",
        bench_def.type_name, json_ref
    ));
    output.push_str("        assert!(result.is_ok(), \"facet_format_json deserialize failed: {:?}\", result.err());\n");
    output.push_str("    }\n\n");

    // facet_json test
    output.push_str("    #[test]\n");
    output.push_str("    fn test_facet_json_deserialize() {\n");
    output.push_str(&format!(
        "        let result = facet_json::from_slice::<{}>({});\n",
        bench_def.type_name, json_ref
    ));
    output.push_str(
        "        assert!(result.is_ok(), \"facet_json deserialize failed: {:?}\", result.err());\n",
    );
    output.push_str("    }\n\n");

    // cranelift test
    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    #[test]\n");
    output.push_str("    fn test_facet_json_cranelift_deserialize() {\n");
    if is_brotli {
        output
            .push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(&*JSON) };\n");
    } else {
        output.push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n");
    }
    output.push_str(&format!(
        "        let result = facet_json::cranelift::from_str_with_fallback::<{}>(json_str);\n",
        bench_def.type_name
    ));
    output.push_str(
        "        assert!(result.is_ok(), \"cranelift deserialize failed: {:?}\", result.err());\n",
    );
    output.push_str("    }\n\n");

    // serde_json test
    output.push_str("    #[test]\n");
    output.push_str("    fn test_serde_json_deserialize() {\n");
    output.push_str(&format!(
        "        let result = serde_json::from_slice::<{}>({});\n",
        bench_def.type_name, json_ref
    ));
    output.push_str(
        "        assert!(result.is_ok(), \"serde_json deserialize failed: {:?}\", result.err());\n",
    );
    output.push_str("    }\n\n");

    // SERIALIZE tests
    output.push_str("    // ===== SERIALIZE TESTS =====\n\n");

    // facet_format_json serialize
    output.push_str("    #[test]\n");
    output.push_str("    fn test_facet_format_json_serialize() {\n");
    output.push_str("        let result = facet_format_json::to_string(&*DATA);\n");
    output.push_str("        assert!(result.is_ok(), \"facet_format_json serialize failed: {:?}\", result.err());\n");
    output.push_str("    }\n\n");

    // facet_json serialize (returns String, not Result)
    output.push_str("    #[test]\n");
    output.push_str("    fn test_facet_json_serialize() {\n");
    output.push_str("        let _result = facet_json::to_string(&*DATA);\n");
    output.push_str("    }\n\n");

    // serde_json serialize
    output.push_str("    #[test]\n");
    output.push_str("    fn test_serde_json_serialize() {\n");
    output.push_str("        let result = serde_json::to_string(&*DATA);\n");
    output.push_str(
        "        assert!(result.is_ok(), \"serde_json serialize failed: {:?}\", result.err());\n",
    );
    output.push_str("    }\n");

    output.push_str("}\n\n");
    Ok(output)
}

fn get_json_content(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    if let Some(ref json_data) = bench_def.json {
        Ok(json_data.content.clone())
    } else if let Some(ref json_file) = bench_def.json_file {
        // Read JSON from file (relative to facet-json/benches/)
        let file_path = workspace_root
            .join("facet-json/benches")
            .join(&json_file.path);
        fs::read_to_string(&file_path)
            .map_err(|e| format!("Failed to read {}: {}", file_path.display(), e).into())
    } else if let Some(ref generated) = bench_def.generated {
        generate_json_data(&generated.generator_name)
    } else {
        Err("Benchmark must have 'json', 'json_file', 'json_brotli', or 'generated'".into())
    }
}

/// Generate JSON data for well-known benchmark patterns.
/// This runs at codegen time, so the data is embedded in the generated benchmark.
fn generate_json_data(generator_name: &str) -> Result<String, Box<dyn std::error::Error>> {
    match generator_name {
        "booleans" => {
            // 10,000 alternating booleans
            let data: Vec<bool> = (0..10000).map(|i| i % 2 == 0).collect();
            Ok(serde_json::to_string(&data)?)
        }
        "integers" => {
            // 1,000 large integers
            let data: Vec<u64> = (0..1000).map(|i| i * 12345678901234).collect();
            Ok(serde_json::to_string(&data)?)
        }
        "floats" => {
            // 1,000 floats
            let data: Vec<f64> = (0..1000).map(|i| i as f64 * 1.23456789).collect();
            Ok(serde_json::to_string(&data)?)
        }
        "short_strings" => {
            // 1,000 short strings (~10 chars each)
            let data: Vec<String> = (0..1000).map(|i| format!("str_{:06}", i)).collect();
            Ok(serde_json::to_string(&data)?)
        }
        "long_strings" => {
            // 100 long strings (1000 chars each)
            let data: Vec<String> = (0..100)
                .map(|i| "x".repeat(1000) + &format!("_{}", i))
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        "escaped_strings" => {
            // 1,000 strings with escape characters
            let data: Vec<String> = (0..1000)
                .map(|i| format!("line_{}\nwith\ttabs\tand \"quotes\" and \\backslashes\\", i))
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        "hashmaps" => {
            // 1,000 key-value pairs
            let data: std::collections::HashMap<String, u64> =
                (0..1000).map(|i| (format!("key_{}", i), i * 2)).collect();
            Ok(serde_json::to_string(&data)?)
        }
        "nested_structs" => {
            // 500 nested structs - generate as JSON directly
            let data: Vec<serde_json::Value> = (0..500)
                .map(|i| {
                    serde_json::json!({
                        "id": i,
                        "inner": {
                            "name": format!("name_{}", i),
                            "value": i as f64 * 1.5,
                            "deep": {
                                "flag": i % 2 == 0,
                                "count": i * 10
                            }
                        }
                    })
                })
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        "options" => {
            // 500 structs with optional fields
            let data: Vec<serde_json::Value> = (0..500)
                .map(|i| {
                    let mut obj = serde_json::json!({
                        "required": i,
                    });
                    if i % 2 == 0 {
                        obj["optional_string"] = serde_json::Value::String(format!("str_{}", i));
                    }
                    if i % 3 == 0 {
                        obj["optional_number"] = serde_json::Value::Number(
                            serde_json::Number::from_f64(i as f64).unwrap(),
                        );
                    }
                    obj
                })
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        "flatten_2enums" => {
            // 1000 configs with 2 flattened enums (4 combinations each)
            let data: Vec<serde_json::Value> = (0..250)
                .flat_map(|i| {
                    vec![
                        // Password + Tcp
                        serde_json::json!({
                            "name": format!("service_{}", i * 4),
                            "Password": { "password": "secret" },
                            "Tcp": { "tcp_port": 8080 }
                        }),
                        // Password + Unix
                        serde_json::json!({
                            "name": format!("service_{}", i * 4 + 1),
                            "Password": { "password": "secret" },
                            "Unix": { "socket_path": "/tmp/sock" }
                        }),
                        // Token + Tcp
                        serde_json::json!({
                            "name": format!("service_{}", i * 4 + 2),
                            "Token": { "token": "abc123", "token_expiry": 3600 },
                            "Tcp": { "tcp_port": 9090 }
                        }),
                        // Token + Unix
                        serde_json::json!({
                            "name": format!("service_{}", i * 4 + 3),
                            "Token": { "token": "xyz789", "token_expiry": 7200 },
                            "Unix": { "socket_path": "/var/run/app.sock" }
                        }),
                    ]
                })
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        "flatten_4enums" => {
            // ~1000 configs with 4 flattened enums (16 combinations each)
            let data: Vec<serde_json::Value> = (0..64)
                .flat_map(|batch| {
                    // Generate all 16 combinations
                    let auths = [
                        serde_json::json!({"Password": {"password": "secret"}}),
                        serde_json::json!({"Token": {"token": "abc123", "token_expiry": 3600}}),
                    ];
                    let transports = [
                        serde_json::json!({"Tcp": {"tcp_port": 8080}}),
                        serde_json::json!({"Unix": {"socket_path": "/tmp/sock"}}),
                    ];
                    let storages = [
                        serde_json::json!({"Local": {"local_path": "/data"}}),
                        serde_json::json!({"Remote": {"remote_url": "https://example.com"}}),
                    ];
                    let loggings = [
                        serde_json::json!({"File": {"log_path": "/var/log/app.log"}}),
                        serde_json::json!({"Stdout": {"log_color": true}}),
                    ];

                    let mut configs = Vec::with_capacity(16);
                    let mut idx = 0;
                    for auth in &auths {
                        for transport in &transports {
                            for storage in &storages {
                                for logging in &loggings {
                                    let mut obj = serde_json::json!({
                                        "name": format!("service_{}_{}", batch, idx),
                                    });
                                    // Merge flattened fields
                                    if let serde_json::Value::Object(m) = auth {
                                        for (k, v) in m {
                                            obj[k] = v.clone();
                                        }
                                    }
                                    if let serde_json::Value::Object(m) = transport {
                                        for (k, v) in m {
                                            obj[k] = v.clone();
                                        }
                                    }
                                    if let serde_json::Value::Object(m) = storage {
                                        for (k, v) in m {
                                            obj[k] = v.clone();
                                        }
                                    }
                                    if let serde_json::Value::Object(m) = logging {
                                        for (k, v) in m {
                                            obj[k] = v.clone();
                                        }
                                    }
                                    configs.push(obj);
                                    idx += 1;
                                }
                            }
                        }
                    }
                    configs
                })
                .collect();
            Ok(serde_json::to_string(&data)?)
        }
        _ => Err(format!("Unknown generator: {}", generator_name).into()),
    }
}
