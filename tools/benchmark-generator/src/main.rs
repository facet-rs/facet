//! Generate benchmark code from benchmarks.kdl definitions.
//!
//! This ensures every benchmark has BOTH divan (wall-clock) AND gungraun (instruction count) versions
//! for ALL 5 targets (facet_format_jit, facet_format_json, facet_json, facet_json_cranelift, serde_json).

use facet::Facet;
use facet_kdl as kdl; // Make kdl:: paths work in attributes
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Facet)]
struct BenchmarkFile {
    #[facet(kdl::children, default)]
    benchmarks: Vec<BenchmarkDef>,
    #[facet(kdl::children, default)]
    type_defs: Vec<TypeDef>,
}

#[derive(Debug, Facet, Clone)]
struct BenchmarkDef {
    #[facet(kdl::property)]
    name: String,
    #[facet(kdl::property, rename = "type")]
    type_name: String,
    #[facet(kdl::property)]
    category: String,
    #[facet(kdl::child, default)]
    json: Option<JsonData>,
    #[facet(kdl::child, default)]
    json_file: Option<JsonFile>,
}

#[derive(Debug, Facet, Clone)]
struct JsonData {
    #[facet(kdl::argument)]
    content: String,
}

#[derive(Debug, Facet, Clone)]
struct JsonFile {
    #[facet(kdl::argument)]
    path: String,
}

#[derive(Debug, Facet, Clone)]
struct TypeDef {
    #[facet(kdl::property)]
    name: String,
    #[facet(kdl::child)]
    code: CodeBlock,
}

#[derive(Debug, Facet, Clone)]
struct CodeBlock {
    #[facet(kdl::argument)]
    content: String,
}

fn main() {
    let args: Vec<String> = env::args().skip(1).collect();

    // Find workspace root by looking for Cargo.toml with [workspace]
    let workspace_root = find_workspace_root().unwrap_or_else(|| {
        eprintln!("Could not find workspace root");
        std::process::exit(1);
    });

    let kdl_path = args
        .first()
        .map(PathBuf::from)
        .unwrap_or_else(|| workspace_root.join("facet-json/benches/benchmarks.kdl"));

    let divan_path = workspace_root.join("facet-json/benches/unified_benchmarks_divan.rs");
    let gungraun_path = workspace_root.join("facet-json/benches/unified_benchmarks_gungraun.rs");

    match generate_benchmarks(&kdl_path, &divan_path, &gungraun_path, &workspace_root) {
        Ok(()) => {
            println!("\nðŸŽ‰ Success! Run benchmarks with:");
            println!(
                "   cargo bench --bench unified_benchmarks_divan --features cranelift --features jit"
            );
            println!(
                "   cargo bench --bench unified_benchmarks_gungraun --features cranelift --features jit"
            );
        }
        Err(e) => {
            eprintln!("âŒ Error generating benchmarks: {}", e);
            std::process::exit(1);
        }
    }
}

fn find_workspace_root() -> Option<PathBuf> {
    let mut current = env::current_dir().ok()?;
    loop {
        let cargo_toml = current.join("Cargo.toml");
        if cargo_toml.exists()
            && let Ok(content) = fs::read_to_string(&cargo_toml)
            && content.contains("[workspace]")
        {
            return Some(current);
        }
        if !current.pop() {
            return None;
        }
    }
}

fn generate_benchmarks(
    kdl_path: &Path,
    divan_output_path: &Path,
    gungraun_output_path: &Path,
    workspace_root: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    println!(
        "ðŸ“– Reading benchmark definitions from {}",
        kdl_path.display()
    );

    let kdl_content = fs::read_to_string(kdl_path)?;
    let file: BenchmarkFile = match facet_kdl::from_str(&kdl_content) {
        Ok(f) => f,
        Err(e) => {
            eprintln!("âŒ Failed to parse KDL:");
            eprintln!("{:?}", e);
            return Err(e.into());
        }
    };

    let benchmarks = file.benchmarks;
    let type_defs = file.type_defs;

    println!("   Found {} benchmarks", benchmarks.len());
    println!("   Found {} type definitions", type_defs.len());

    // Generate DIVAN benchmarks
    let divan_output = generate_divan_benchmarks(&benchmarks, &type_defs, workspace_root)?;
    println!(
        "âœï¸  Writing divan benchmarks to {}",
        divan_output_path.display()
    );
    fs::write(divan_output_path, divan_output)?;

    // Generate GUNGRAUN benchmarks
    let gungraun_output = generate_gungraun_benchmarks(&benchmarks, &type_defs, workspace_root)?;
    println!(
        "âœï¸  Writing gungraun benchmarks to {}",
        gungraun_output_path.display()
    );
    fs::write(gungraun_output_path, gungraun_output)?;

    println!(
        "âœ… Generated {} benchmarks Ã— 5 targets Ã— 2 harnesses = {} total benchmark functions!",
        benchmarks.len(),
        benchmarks.len() * 5 * 2
    );

    Ok(())
}

fn generate_divan_benchmarks(
    benchmarks: &[BenchmarkDef],
    type_defs: &[TypeDef],
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by benchmark-generator\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str(
        "//! This file ensures parity: every benchmark has BOTH divan AND gungraun versions\n",
    );
    output.push_str("//! for ALL 5 targets.\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("use facet_format_json::JsonParser;\n");
    output.push_str("use divan::Bencher;\n");
    output.push_str("use std::hint::black_box;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate only DIVAN benchmark modules
    for bench_def in benchmarks {
        output.push_str(&generate_divan_benchmark_module(bench_def, workspace_root)?);
    }

    // Entry point for divan harness
    output.push_str("fn main() {\n");
    output.push_str("    divan::main();\n");
    output.push_str("}\n");

    Ok(output)
}

fn generate_gungraun_benchmarks(
    benchmarks: &[BenchmarkDef],
    type_defs: &[TypeDef],
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by benchmark-generator\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str("//! Gungraun benchmarks (instruction counts)\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("use facet_format_json::JsonParser;\n");
    output.push_str("use std::hint::black_box;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate only GUNGRAUN benchmark modules
    for bench_def in benchmarks {
        output.push_str(&generate_gungraun_benchmark_module(
            bench_def,
            workspace_root,
        )?);
    }

    // Generate gungraun groups
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Gungraun Benchmark Groups\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    // Re-export gungraun benchmarks at module level for macro compatibility
    output.push_str("// Re-export gungraun benchmarks (macro doesn't support :: paths)\n");
    for bench_def in benchmarks {
        output.push_str(&format!(
            "use {}::gungraun_{}_facet_format_jit as gungraun_{}_facet_format_jit;\n",
            bench_def.name, bench_def.name, bench_def.name
        ));
        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "use {}::gungraun_{}_{}_deserialize as gungraun_{}_{};\n",
                bench_def.name, bench_def.name, target, bench_def.name, target
            ));
        }
        output.push_str(&format!(
            "#[cfg(feature = \"cranelift\")]\nuse {}::gungraun_{}_facet_json_cranelift as gungraun_{}_facet_json_cranelift;\n",
            bench_def.name, bench_def.name, bench_def.name
        ));
    }
    output.push('\n');

    for bench_def in benchmarks {
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_benchmarks;\n    benchmarks =\n",
            bench_def.name
        ));

        for target in &[
            "facet_format_jit",
            "facet_format_json",
            "facet_json",
            "serde_json",
        ] {
            output.push_str(&format!(
                "        gungraun_{}_{},\n",
                bench_def.name, target
            ));
        }

        output.push_str(");\n\n");

        // Cranelift group
        output.push_str("#[cfg(feature = \"cranelift\")]\n");
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_cranelift;\n    benchmarks = gungraun_{}_facet_json_cranelift\n);\n\n",
            bench_def.name, bench_def.name
        ));
    }

    // Main gungraun entry point
    output.push_str("// Gungraun main\n");
    output.push_str("#[cfg(not(feature = \"cranelift\"))]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!("        {}_benchmarks", bench_def.name));
    }
    output.push_str("\n);\n\n");

    output.push_str("#[cfg(feature = \"cranelift\")]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!(
            "        {}_benchmarks,\n        {}_cranelift",
            bench_def.name, bench_def.name
        ));
    }
    output.push_str("\n);\n");

    Ok(output)
}

fn generate_divan_benchmark_module(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// BENCHMARK: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod {} {{\n", bench_def.name));
    output.push_str("    use super::*;\n\n");

    // JSON data
    let json_content = get_json_content(bench_def, workspace_root)?;
    output.push_str(&format!(
        "    static JSON: &[u8] = br#\"{}\"#;\n\n",
        json_content
    ));

    // Only DIVAN benchmarks
    output.push_str("    // ===== DIVAN (wall-clock) =====\n\n");

    let targets = vec![
        (
            "facet_format_jit",
            "format_jit::deserialize_with_fallback",
            "JsonParser::new",
            true,
        ),
        (
            "facet_format_json",
            "facet_format_json::from_slice",
            "",
            false,
        ),
        ("facet_json", "facet_json::from_slice", "", false),
        (
            "facet_json_cranelift",
            "facet_json::cranelift::from_str_with_fallback",
            "",
            false,
        ),
        ("serde_json", "serde_json::from_slice", "", false),
    ];

    for (target_name, deserialize_fn, wrapper, needs_parser) in &targets {
        let is_cranelift = target_name.contains("cranelift");
        let is_str = is_cranelift;

        if is_cranelift {
            output.push_str("    #[cfg(feature = \"cranelift\")]\n");
        }

        output.push_str("    #[divan::bench]\n");
        output.push_str(&format!(
            "    fn {}_deserialize(bencher: Bencher) {{\n",
            target_name
        ));

        if is_str {
            output.push_str(
                "        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n",
            );
        }

        output.push_str("        bencher.bench(|| {\n");

        if *needs_parser {
            output.push_str(&format!(
                "            black_box({}::<{}, _>({}(black_box(JSON))).unwrap())\n",
                deserialize_fn, bench_def.type_name, wrapper
            ));
        } else if is_str {
            output.push_str(&format!(
                "            black_box({}::<{}>(black_box(json_str)).unwrap())\n",
                deserialize_fn, bench_def.type_name
            ));
        } else {
            output.push_str(&format!(
                "            black_box({}::<{}>(black_box(JSON)).unwrap())\n",
                deserialize_fn, bench_def.type_name
            ));
        }

        output.push_str("        });\n");
        output.push_str("    }\n\n");
    }

    output.push_str("}\n\n");
    Ok(output)
}

fn generate_gungraun_benchmark_module(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// BENCHMARK: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod {} {{\n", bench_def.name));
    output.push_str("    use super::*;\n\n");

    // JSON data
    let json_content = get_json_content(bench_def, workspace_root)?;
    output.push_str(&format!(
        "    static JSON: &[u8] = br#\"{}\"#;\n\n",
        json_content
    ));

    // Only GUNGRAUN benchmarks
    output.push_str("    // ===== GUNGRAUN (instruction counts) =====\n\n");

    // JIT warmup
    output.push_str("    fn setup_jit() -> &'static [u8] {\n");
    output.push_str(&format!(
        "        let _ = format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new(JSON));\n",
        bench_def.type_name
    ));
    output.push_str("        JSON\n");
    output.push_str("    }\n\n");

    output.push_str("    #[gungraun::library_benchmark]\n");
    output.push_str("    #[bench::cached(setup = setup_jit)]\n");
    output.push_str(&format!(
        "    fn gungraun_{}_facet_format_jit(json: &[u8]) -> ",
        bench_def.name
    ));
    output.push_str(&bench_def.type_name);
    output.push_str(" {\n");
    output.push_str("        let parser = JsonParser::new(black_box(json));\n");
    output.push_str(&format!(
        "        black_box(format_jit::deserialize_with_fallback::<{}, _>(parser).unwrap())\n",
        bench_def.type_name
    ));
    output.push_str("    }\n\n");

    // Other gungraun targets (no warmup needed)
    for target in &["facet_format_json", "facet_json", "serde_json"] {
        output.push_str("    #[gungraun::library_benchmark]\n");
        output.push_str(&format!(
            "    fn gungraun_{}_{}_deserialize() -> {} {{\n",
            bench_def.name, target, bench_def.type_name
        ));
        output.push_str(&format!(
            "        black_box({}::from_slice::<{}>(black_box(JSON)).unwrap())\n",
            target, bench_def.type_name
        ));
        output.push_str("    }\n\n");
    }

    // Cranelift gungraun with warmup
    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    fn setup_cranelift() -> &'static str {\n");
    output.push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n");
    output.push_str(&format!(
        "        let _ = facet_json::cranelift::from_str_with_fallback::<{}>(json_str);\n",
        bench_def.type_name
    ));
    output.push_str("        json_str\n");
    output.push_str("    }\n\n");

    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    #[gungraun::library_benchmark]\n");
    output.push_str("    #[bench::cached(setup = setup_cranelift)]\n");
    output.push_str(&format!(
        "    fn gungraun_{}_facet_json_cranelift(json: &str) -> {} {{\n",
        bench_def.name, bench_def.type_name
    ));
    output.push_str(&format!(
        "        black_box(facet_json::cranelift::from_str_with_fallback::<{}>(black_box(json)).unwrap())\n",
        bench_def.type_name
    ));
    output.push_str("    }\n");

    output.push_str("}\n\n");
    Ok(output)
}

fn get_json_content(
    bench_def: &BenchmarkDef,
    workspace_root: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    if let Some(ref json_data) = bench_def.json {
        Ok(json_data.content.clone())
    } else if let Some(ref json_file) = bench_def.json_file {
        // Read JSON from file (relative to facet-json/benches/)
        let file_path = workspace_root
            .join("facet-json/benches")
            .join(&json_file.path);
        fs::read_to_string(&file_path)
            .map_err(|e| format!("Failed to read {}: {}", file_path.display(), e).into())
    } else {
        Err("Benchmark must have either 'json' or 'json_file'".into())
    }
}
