# facet-html

HTML parser and serializer for the facet format architecture. For typed HTML5 element definitions, see [facet-html-dom](https://crates.io/crates/facet-html-dom).

This crate builds on [facet-dom](https://crates.io/crates/facet-dom) with HTML-specific behaviors.

## Differences from facet-xml

While `facet-html` shares the DOM-based architecture with `facet-xml`, there are key differences:

| Feature | facet-xml | facet-html |
|---------|-----------|------------|
| Naming convention | lowerCamelCase | lowercase |
| Fragment handling | As-is | Auto-wrapped in `<html><body>` when target is `Html` |
| Void elements | Must be self-closing | Handled per HTML5 spec (`<br>`, `<img>`, etc.) |
| Raw text elements | N/A | `<script>`, `<style>` preserve content |

## Basic Usage

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Greeting {
    #[facet(html::text)]
    message: String,
}

let html = "<greeting>Hello, world!</greeting>";
let g: Greeting = facet_html::from_str(html).unwrap();
assert_eq!(g.message, "Hello, world!");
```

## Attributes

Use `html::attribute` to capture HTML attributes:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Anchor {
    #[facet(html::attribute)]
    href: String,
    
    #[facet(html::text, default)]
    text: String,
}

let html = r#"<anchor href="/home">Home</anchor>"#;
let a: Anchor = facet_html::from_str(html).unwrap();
assert_eq!(a.href, "/home");
assert_eq!(a.text, "Home");
```

## Text Content

Use `html::text` to capture text content:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Paragraph {
    #[facet(html::text)]
    content: String,
}

let html = "<paragraph>Some text here</paragraph>";
let p: Paragraph = facet_html::from_str(html).unwrap();
assert_eq!(p.content, "Some text here");
```

## Child Elements

Fields without special attributes match child elements by name (lowercase):

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Person {
    name: String,
    age: u32,
}

#[derive(Facet, Debug)]
struct Name {
    #[facet(html::text)]
    value: String,
}

#[derive(Facet, Debug)]
struct Age {
    #[facet(html::text)]
    value: u32,
}

let html = "<person><name>Alice</name><age>30</age></person>";
// Note: This expects <name> and <age> to be parsed as structs
```

## Custom Elements (Dynamic Tag Names)

Use `html::tag` to capture the element's tag name, enabling custom element support:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct CustomElement {
    #[facet(html::tag)]
    tag: String,
    
    #[facet(html::text, default)]
    content: String,
}

let html = "<my-component>Hello</my-component>";
let elem: CustomElement = facet_html::from_str(html).unwrap();
assert_eq!(elem.tag, "my-component");
assert_eq!(elem.content, "Hello");
```

## Enums with Custom Element Fallback

Use `html::custom_element` on an enum variant to catch unknown elements:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug, PartialEq)]
#[repr(u8)]
enum Content {
    #[facet(rename = "p")]
    Paragraph {
        #[facet(html::text)]
        text: String,
    },
    #[facet(rename = "div")]
    Div {
        #[facet(html::text)]
        text: String,
    },
    #[facet(html::custom_element)]
    Custom {
        #[facet(html::tag)]
        tag: String,
        #[facet(html::text, default)]
        text: String,
    },
}

let html = "<unknown-tag>content</unknown-tag>";
let content: Content = facet_html::from_str(html).unwrap();
assert!(matches!(content, Content::Custom { tag, .. } if tag == "unknown-tag"));
```

## Document vs Fragment Parsing

When parsing into a document type (like `Html` from `facet-html-dom`), HTML fragments
are automatically wrapped in `<html><body>`:

```rust,ignore
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug, Default)]
struct Body {
    #[facet(flatten, default)]
    children: Vec<BodyContent>,
}

#[derive(Facet, Debug, PartialEq)]
#[repr(u8)]
enum BodyContent {
    #[facet(rename = "_text", html::text)]
    Text(String),
    #[facet(rename = "p")]
    P {
        #[facet(html::text)]
        text: String,
    },
}

#[derive(Facet, Debug, Default)]
#[facet(rename = "html")]
struct Html {
    #[facet(default, other)]
    body: Option<Body>,
}

// Fragment input - no <html> wrapper
let html = "<p>Hello</p>";
let doc: Html = facet_html::from_str(html).unwrap();

// The <p> is captured in body via #[facet(other)]
assert!(doc.body.is_some());
```

The `#[facet(other)]` attribute on a field makes it a fallback: when the root element
doesn't match the struct's expected name, the content is deserialized into that field instead.

**Note:** This feature is not yet implemented.

## Flattened Heterogeneous Children

Same as facet-xml - use `#[facet(flatten)]` on `Vec<Enum>` for direct child elements:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug, PartialEq)]
#[repr(u8)]
enum Item {
    #[facet(rename = "li")]
    Li {
        #[facet(html::text)]
        text: String,
    },
}

#[derive(Facet, Debug)]
#[facet(rename = "ul")]
struct Ul {
    #[facet(flatten)]
    items: Vec<Item>,
}

let html = "<ul><li>One</li><li>Two</li></ul>";
let ul: Ul = facet_html::from_str(html).unwrap();
assert_eq!(ul.items.len(), 2);
```

## Serialization

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Div {
    #[facet(html::attribute, default)]
    class: Option<String>,
    
    #[facet(html::text, default)]
    content: String,
}

let div = Div {
    class: Some("container".to_string()),
    content: "Hello".to_string(),
};

let html = facet_html::to_string(&div).unwrap();
assert!(html.contains("class=\"container\""));
assert!(html.contains("Hello"));
```

## Pretty Printing

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
struct Doc {
    #[facet(html::text)]
    content: String,
}

let doc = Doc { content: "Hello".to_string() };
let pretty = facet_html::to_string_pretty(&doc).unwrap();
// Pretty-printed output with indentation
```

## Whitespace Handling in Element Lists

When deserializing a `Vec<T>` with `html::elements`, text nodes (including whitespace)
are handled based on what `T` can accept:

### Case 1: Vec of structs - text is ignored

When `T` is a struct, text nodes cannot be deserialized into it, so they are skipped:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
#[facet(rename = "li")]
struct Li {
    #[facet(html::text, default)]
    text: String,
}

#[derive(Facet, Debug)]
#[facet(rename = "ul")]
struct Ul {
    #[facet(html::elements, default)]
    li: Vec<Li>,
}

// Whitespace between elements is ignored - only <li> elements are collected
let html = "<ul>
    <li>One</li>
    <li>Two</li>
</ul>";
let ul: Ul = facet_html::from_str(html).unwrap();
assert_eq!(ul.li.len(), 2);
assert_eq!(ul.li[0].text, "One");
assert_eq!(ul.li[1].text, "Two");
```

### Case 2: Vec of String - element text content is collected

When `T` is `String`, the text content of each matched element is collected:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug)]
#[facet(rename = "container")]
struct Container {
    #[facet(html::elements, default)]
    item: Vec<String>,
}

// Each <item> element's text content becomes a list item
// Whitespace between elements is ignored
let html = "<container>
    <item>First</item>
    <item>Second</item>
</container>";
let c: Container = facet_html::from_str(html).unwrap();
assert_eq!(c.item.len(), 2);
assert_eq!(c.item[0], "First");
assert_eq!(c.item[1], "Second");
```

### Case 3: Vec of enum with text variant - text is wrapped

When `T` is an enum that has a variant capable of holding text, text nodes are
wrapped in that variant:

```rust
# use facet::Facet;
# use facet_html as html;
#[derive(Facet, Debug, PartialEq)]
#[repr(u8)]
enum Content {
    #[facet(rename = "_text", html::text)]
    Text(String),
    #[facet(rename = "em")]
    Em {
        #[facet(html::text)]
        text: String,
    },
}

#[derive(Facet, Debug)]
#[facet(rename = "p")]
struct P {
    #[facet(flatten, default)]
    children: Vec<Content>,
}

// Mixed text and elements - text becomes Content::Text variant
let html = "<p>Hello <em>world</em>!</p>";
let p: P = facet_html::from_str(html).unwrap();
assert_eq!(p.children.len(), 3);
assert_eq!(p.children[0], Content::Text("Hello ".to_string()));
assert!(matches!(p.children[1], Content::Em { .. }));
assert_eq!(p.children[2], Content::Text("!".to_string()));
```
