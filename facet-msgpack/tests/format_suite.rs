#![forbid(unsafe_code)]

use facet::Facet;
use facet_format::DeserializeError;
use facet_format_suite::{CaseOutcome, CaseSpec, FormatSuite, all_cases, msgpack};
use facet_msgpack::{MsgPackError, MsgPackParser, to_vec};
use libtest_mimic::{Arguments, Failed, Trial};

struct MsgPackSlice;

impl FormatSuite for MsgPackSlice {
    type Error = DeserializeError<MsgPackError>;

    fn format_name() -> &'static str {
        "facet-msgpack/slice"
    }

    fn highlight_language() -> Option<&'static str> {
        None // Binary format, no syntax highlighting
    }

    fn deserialize<T>(input: &[u8]) -> Result<T, Self::Error>
    where
        T: Facet<'static> + core::fmt::Debug,
    {
        use facet_format::FormatDeserializer;
        let parser = MsgPackParser::new(input);
        let mut de = FormatDeserializer::new_owned(parser);
        de.deserialize_root::<T>()
    }

    fn serialize<T>(value: &T) -> Option<Result<Vec<u8>, String>>
    where
        for<'facet> T: Facet<'facet>,
        T: core::fmt::Debug,
    {
        Some(to_vec(value).map_err(|e| e.to_string()))
    }

    // MsgPack tests use rmp-serde (reference implementation) to generate input bytes.
    // This ensures interoperability testing against known-good MsgPack data.

    fn struct_single_field() -> CaseSpec {
        // Input generated by rmp-serde serializing StructSingleField { name: "facet" }
        CaseSpec::from_bytes_vec(msgpack::struct_single_field_bytes())
    }

    fn sequence_numbers() -> CaseSpec {
        // Input generated by rmp-serde serializing vec![1u64, 2, 3]
        CaseSpec::from_bytes_vec(msgpack::sequence_numbers_bytes())
    }

    fn sequence_mixed_scalars() -> CaseSpec {
        CaseSpec::skip("MixedScalar enum serialization differs between serde and facet")
    }

    fn struct_nested() -> CaseSpec {
        // Input generated by rmp-serde serializing NestedParent
        CaseSpec::from_bytes_vec(msgpack::struct_nested_bytes())
    }

    fn enum_complex() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::enum_complex_bytes())
    }

    fn attr_rename_field() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_all_camel() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_default_field() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_default_struct() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_default_function() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn option_none() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::option_none_bytes())
    }

    fn option_some() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::option_some_bytes())
    }

    fn option_null() -> CaseSpec {
        // rmp-serde serializes None as null, which is same as option_none for msgpack
        CaseSpec::from_bytes_vec(msgpack::option_none_bytes())
    }

    fn attr_skip_serializing() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_skip_serializing_if() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_skip() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn enum_internally_tagged() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn enum_adjacently_tagged() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn struct_flatten() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn transparent_newtype() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn deny_unknown_fields() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn error_type_mismatch_string_to_int() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn error_type_mismatch_object_to_array() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn error_missing_required_field() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_alias() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_vs_alias_precedence() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_all_kebab() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_all_screaming() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_unicode() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn attr_rename_special_chars() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_container() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_field_level() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_validation_error() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_with_option() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_with_enum() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn proxy_with_transparent() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn opaque_proxy() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn opaque_proxy_option() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn transparent_multilevel() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn transparent_option() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn transparent_nonzero() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn flatten_optional_some() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn flatten_optional_none() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn flatten_overlapping_fields_error() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn flatten_multilevel() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn flatten_multiple_enums() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn scalar_bool() -> CaseSpec {
        // Input generated by rmp-serde serializing BoolWrapper
        CaseSpec::from_bytes_vec(msgpack::scalar_bool_bytes())
    }

    fn scalar_integers() -> CaseSpec {
        // Input generated by rmp-serde serializing IntegerTypes
        CaseSpec::from_bytes_vec(msgpack::scalar_integers_bytes())
    }

    fn scalar_floats() -> CaseSpec {
        // Input generated by rmp-serde serializing FloatTypes
        CaseSpec::from_bytes_vec(msgpack::scalar_floats_bytes())
    }

    fn map_string_keys() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::map_string_keys_bytes())
    }

    fn tuple_simple() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::tuple_simple_bytes())
    }

    fn tuple_nested() -> CaseSpec {
        // Nested tuples have different array representation in serde
        CaseSpec::skip("Nested tuple representation differs between serde and facet")
    }

    fn tuple_empty() -> CaseSpec {
        // serde serializes () as null, facet expects empty array
        CaseSpec::skip("Empty tuple representation differs: serde=null, facet=[]")
    }

    fn tuple_single_element() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::tuple_single_element_bytes())
    }

    fn tuple_struct_variant() -> CaseSpec {
        CaseSpec::skip("Enum tuple variants have different representation in serde vs facet")
    }

    fn tuple_newtype_variant() -> CaseSpec {
        CaseSpec::skip("Enum newtype variants have different representation in serde vs facet")
    }

    fn enum_unit_variant() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::enum_unit_variant_bytes())
    }

    fn numeric_enum() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn signed_numeric_enum() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn inferred_numeric_enum() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn enum_untagged() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn enum_variant_rename() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn untagged_with_null() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn untagged_newtype_variant() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn untagged_as_field() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn untagged_unit_only() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn box_wrapper() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::box_wrapper_bytes())
    }

    fn arc_wrapper() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::arc_wrapper_bytes())
    }

    fn rc_wrapper() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::rc_wrapper_bytes())
    }

    fn set_btree() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::set_btree_bytes())
    }

    fn scalar_integers_16() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::scalar_integers_16_bytes())
    }

    fn scalar_integers_128() -> CaseSpec {
        // serde serializes i128/u128 as byte arrays, not native integers
        CaseSpec::skip("i128/u128 serialized as byte arrays by serde, not native integers")
    }

    fn scalar_integers_size() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::scalar_integers_size_bytes())
    }

    fn nonzero_integers() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::nonzero_integers_bytes())
    }

    fn cow_str() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::cow_str_bytes())
    }

    fn bytes_vec_u8() -> CaseSpec {
        // serde serializes Vec<u8> as binary, facet expects array of integers
        CaseSpec::skip("Vec<u8> representation differs: serde=binary, facet=array")
    }

    fn array_fixed_size() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::array_fixed_size_bytes())
    }

    fn skip_unknown_fields() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::skip_unknown_fields_bytes())
    }

    fn string_escapes() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, no string escape sequences")
    }

    fn unit_struct() -> CaseSpec {
        // serde serializes unit struct as array, facet expects map
        CaseSpec::skip("Unit struct representation differs: serde=[], facet={}")
    }

    fn newtype_u64() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn newtype_string() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn char_scalar() -> CaseSpec {
        // serde serializes char as string, need to verify our parser handles it
        CaseSpec::from_bytes_vec(msgpack::char_scalar_bytes())
    }

    fn hashset() -> CaseSpec {
        // HashSet ordering is non-deterministic, skip for now
        CaseSpec::skip("HashSet element ordering is non-deterministic")
    }

    fn vec_nested() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::vec_nested_bytes())
            .without_roundtrip("Round-trip comparison has issues with nested vecs")
    }

    // Third-party types - all need binary input, not JSON strings
    fn uuid() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn ulid() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn camino_path() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn ordered_float() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn rust_decimal() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn scalar_floats_scientific() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, no scientific notation")
    }

    fn string_escapes_extended() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, no string escape sequences")
    }

    fn box_str() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn arc_str() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn rc_str() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn arc_slice() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn nonzero_integers_extended() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn time_offset_datetime() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn jiff_timestamp() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn jiff_civil_datetime() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn chrono_datetime_utc() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn chrono_naive_datetime() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn chrono_naive_date() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn chrono_naive_time() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn chrono_in_vec() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn bytes_bytes() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn bytes_bytes_mut() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn bytestring() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn compact_string() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn smartstring() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn smol_str() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, requires binary input not JSON strings")
    }

    fn value_null() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_bool() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_integer() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_float() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_string() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_array() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    fn value_object() -> CaseSpec {
        CaseSpec::skip("MsgPack is a binary format, DynamicValue not supported")
    }

    // ── Network type cases ──

    fn net_ip_addr_v4() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_ip_addr_v4_bytes())
    }

    fn net_ip_addr_v6() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_ip_addr_v6_bytes())
    }

    fn net_ipv4_addr() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_ipv4_addr_bytes())
    }

    fn net_ipv6_addr() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_ipv6_addr_bytes())
    }

    fn net_socket_addr_v4() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_socket_addr_v4_bytes())
    }

    fn net_socket_addr_v6() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_socket_addr_v6_bytes())
    }

    fn net_socket_addr_v4_explicit() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_socket_addr_v4_explicit_bytes())
    }

    fn net_socket_addr_v6_explicit() -> CaseSpec {
        CaseSpec::from_bytes_vec(msgpack::net_socket_addr_v6_explicit_bytes())
    }
}

fn main() {
    use std::sync::Arc;

    let args = Arguments::from_args();
    let cases: Vec<Arc<_>> = all_cases::<MsgPackSlice>()
        .into_iter()
        .map(Arc::new)
        .collect();

    let mut trials: Vec<Trial> = Vec::new();

    for case in &cases {
        let name = format!("{}::{}", MsgPackSlice::format_name(), case.id);
        let skip_reason = case.skip_reason();
        let case = Arc::clone(case);
        let mut trial = Trial::test(name, move || match case.run() {
            CaseOutcome::Passed => Ok(()),
            CaseOutcome::Skipped(_) => Ok(()),
            CaseOutcome::Failed(msg) => Err(Failed::from(msg)),
        });
        if skip_reason.is_some() {
            trial = trial.with_ignored_flag(true);
        }
        trials.push(trial);
    }

    libtest_mimic::run(&args, trials).exit()
}
