//! WASM client for facet-html-diff
//!
//! Applies DOM patches in the browser using web-sys.
//! This is used to test that patches generated by facet-html-diff
//! correctly transform the DOM when applied in a real browser.

use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, Node};

// Re-export patch types for reference
pub use facet_html_diff::{NodePath, NodeRef, Patch};

/// Slots for detached nodes during patch application.
/// In Chawathe's model, INSERT doesn't shift - it displaces the occupant to a slot.
struct Slots {
    nodes: Vec<Option<Node>>,
}

impl Slots {
    fn new() -> Self {
        Self { nodes: Vec::new() }
    }

    fn store(&mut self, slot: u32, node: Node) {
        let idx = slot as usize;
        if idx >= self.nodes.len() {
            self.nodes.resize(idx + 1, None);
        }
        self.nodes[idx] = Some(node);
    }

    fn take(&mut self, slot: u32) -> Option<Node> {
        let idx = slot as usize;
        if idx < self.nodes.len() {
            self.nodes[idx].take()
        } else {
            None
        }
    }

    fn get(&self, slot: u32) -> Option<&Node> {
        let idx = slot as usize;
        self.nodes.get(idx).and_then(|n| n.as_ref())
    }
}

/// Apply a list of patches to the current document.
/// Returns the number of patches applied, or an error message.
#[wasm_bindgen]
pub fn apply_patches_json(patches_json: &str) -> Result<usize, JsValue> {
    let patches: Vec<Patch> = facet_json::from_str(patches_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse patches: {e}")))?;

    apply_patches(&patches)
}

/// Apply patches to the document.
pub fn apply_patches(patches: &[Patch]) -> Result<usize, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;

    let count = patches.len();
    log(&format!(
        "[facet-html-diff-wasm] applying {} patches",
        count
    ));

    let mut slots = Slots::new();

    for (i, patch) in patches.iter().enumerate() {
        log(&format!("[facet-html-diff-wasm] patch {}: {:?}", i, patch));
        apply_patch(&document, patch, &mut slots)?;
    }

    Ok(count)
}

fn apply_patch(doc: &Document, patch: &Patch, slots: &mut Slots) -> Result<(), JsValue> {
    match patch {
        Patch::SetText { path, text } => {
            let node = find_node(doc, path, slots)?;
            node.set_text_content(Some(text));
        }

        Patch::SetAttribute { path, name, value } => {
            let el = find_element(doc, path, slots)?;
            el.set_attribute(name, value)?;
        }

        Patch::RemoveAttribute { path, name } => {
            let el = find_element(doc, path, slots)?;
            el.remove_attribute(name)?;
        }

        Patch::Remove { node } => {
            let target = resolve_node_ref(doc, node, slots)?;
            if let Some(parent) = target.parent_node() {
                parent.remove_child(&target)?;
            }
            // If it was a slot, it's now gone
            if let NodeRef::Slot(s) = node {
                slots.take(*s);
            }
        }

        Patch::Replace { path, html } => {
            let el = find_element(doc, path, slots)?;
            // For body element (empty path), use innerHTML
            if path.0.is_empty() {
                let inner = extract_body_inner(html).unwrap_or_else(|| html.clone());
                el.set_inner_html(&inner);
            } else {
                el.set_outer_html(html);
            }
        }

        Patch::InsertAt {
            parent,
            position,
            html,
            detach_to_slot,
        } => {
            let parent_node = resolve_node_ref(doc, parent, slots)?;
            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("parent is not an element"))?;

            let children = parent_el.child_nodes();
            let pos = *position as u32;

            // Parse the new HTML
            let new_node = parse_html_fragment(doc, html)?;

            // If there's a node at this position, replace it (and optionally store in slot)
            if let Some(existing) = children.item(pos) {
                let replaced = parent_el.replace_child(&new_node, &existing)?;
                if let Some(slot) = detach_to_slot {
                    slots.store(*slot, replaced);
                }
            } else {
                // No node at position, just insert
                let reference = parent_el.child_nodes().item(pos);
                parent_el.insert_before(&new_node, reference.as_ref())?;
            }
        }

        Patch::InsertAfter { path, html } => {
            let el = find_element(doc, path, slots)?;
            el.insert_adjacent_html("afterend", html)?;
        }

        Patch::AppendChild { path, html } => {
            let el = find_element(doc, path, slots)?;
            el.insert_adjacent_html("beforeend", html)?;
        }

        Patch::Move {
            from,
            to,
            detach_to_slot,
        } => {
            // Get the node to move (from path or slot)
            let node = match from {
                NodeRef::Path(path) => find_node(doc, path, slots)?,
                NodeRef::Slot(slot) => slots
                    .take(*slot)
                    .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot)))?,
            };

            // Remove from current location (if it has a parent - slots don't)
            if let Some(parent) = node.parent_node() {
                parent.remove_child(&node)?;
            }

            // Find the parent and position from the target path
            if to.0.is_empty() {
                return Err(JsValue::from_str("Move: cannot move to root"));
            }
            let parent_path = NodePath(to.0[..to.0.len() - 1].to_vec());
            let target_idx = to.0[to.0.len() - 1] as u32;

            let parent_node = find_node(doc, &parent_path, slots)?;
            let parent_el = parent_node
                .dyn_ref::<Element>()
                .ok_or_else(|| JsValue::from_str("parent is not an element"))?;

            // Insert at the target position (replace if occupied)
            let children = parent_el.child_nodes();
            if let Some(existing) = children.item(target_idx) {
                let replaced = parent_el.replace_child(&node, &existing)?;
                if let Some(slot) = detach_to_slot {
                    slots.store(*slot, replaced);
                }
            } else {
                let reference = children.item(target_idx);
                parent_el.insert_before(&node, reference.as_ref())?;
            }
        }
    }

    Ok(())
}

/// Resolve a NodeRef to an actual DOM Node.
fn resolve_node_ref(doc: &Document, node_ref: &NodeRef, slots: &Slots) -> Result<Node, JsValue> {
    match node_ref {
        NodeRef::Path(path) => find_node(doc, path, slots),
        NodeRef::Slot(slot) => slots
            .get(*slot)
            .cloned()
            .ok_or_else(|| JsValue::from_str(&format!("slot {} is empty", slot))),
    }
}

/// Find a node by DOM path.
fn find_node(doc: &Document, path: &NodePath, _slots: &Slots) -> Result<Node, JsValue> {
    let body = doc.body().ok_or_else(|| JsValue::from_str("no body"))?;
    let mut current: Node = body.into();

    for &idx in &path.0 {
        let children = current.child_nodes();
        current = children
            .item(idx as u32)
            .ok_or_else(|| JsValue::from_str(&format!("child {} not found", idx)))?;
    }

    Ok(current)
}

/// Find an element by DOM path.
fn find_element(doc: &Document, path: &NodePath, slots: &Slots) -> Result<Element, JsValue> {
    let node = find_node(doc, path, slots)?;
    node.dyn_into::<Element>()
        .map_err(|_| JsValue::from_str("node is not an element"))
}

/// Parse an HTML fragment and return the first child node.
fn parse_html_fragment(doc: &Document, html: &str) -> Result<Node, JsValue> {
    let template = doc
        .create_element("template")
        .map_err(|e| JsValue::from_str(&format!("create template failed: {:?}", e)))?;

    template.set_inner_html(html);

    // Get the template's content (a DocumentFragment)
    let template_el = template
        .dyn_ref::<web_sys::HtmlTemplateElement>()
        .ok_or_else(|| JsValue::from_str("not a template element"))?;

    let content = template_el.content();
    let first_child = content
        .first_child()
        .ok_or_else(|| JsValue::from_str("empty HTML fragment"))?;

    Ok(first_child)
}

/// Extract the inner content of a <body> tag.
fn extract_body_inner(html: &str) -> Option<String> {
    let start = html.find("<body")?.checked_add(5)?;
    let after_tag = html.get(start..)?;
    let content_start = after_tag.find('>')?.checked_add(1)?;
    let content = after_tag.get(content_start..)?;
    let end = content.rfind("</body>")?;
    Some(content.get(..end)?.to_string())
}

/// Log a message to the browser console.
#[wasm_bindgen]
pub fn log(msg: &str) {
    web_sys::console::log_1(&JsValue::from_str(msg));
}

/// Get the innerHTML of the body element.
#[wasm_bindgen]
pub fn get_body_inner_html() -> Result<String, JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    Ok(body.inner_html())
}

/// Set the innerHTML of the body element.
#[wasm_bindgen]
pub fn set_body_inner_html(html: &str) -> Result<(), JsValue> {
    let window = web_sys::window().ok_or_else(|| JsValue::from_str("no window"))?;
    let document = window
        .document()
        .ok_or_else(|| JsValue::from_str("no document"))?;
    let body = document
        .body()
        .ok_or_else(|| JsValue::from_str("no body"))?;

    body.set_inner_html(html);
    Ok(())
}
