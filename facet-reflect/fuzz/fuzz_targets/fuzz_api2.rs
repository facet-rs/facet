//! Fuzzing infrastructure for Partial v2
//!
//! Key insight: instead of generating raw `*const ()` pointers, we generate
//! typed values that get converted to pointers at submit time.

use facet::Facet;
use facet_core::Shape;

// =============================================================================
// Fuzz Value - type-erased but safe value storage
// =============================================================================

/// A value that can be submitted via Set operation.
/// Generated by the fuzzer, converted to ptr+shape at submit time.
#[derive(Debug, Clone)]
pub enum FuzzValue {
    // =========================================================================
    // Core scalars (always available)
    // =========================================================================
    Bool(bool),
    U8(u8),
    U16(u16),
    U32(u32),
    U64(u64),
    U128(u128),
    Usize(usize),
    I8(i8),
    I16(i16),
    I32(i32),
    I64(i64),
    I128(i128),
    Isize(isize),
    F32(f32),
    F64(f64),
    Char(char),
    String(String),

    // =========================================================================
    // Network types (facet-core/net)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Ipv4Addr(std::net::Ipv4Addr),
    #[cfg(feature = "fuzz-all-types")]
    Ipv6Addr(std::net::Ipv6Addr),
    #[cfg(feature = "fuzz-all-types")]
    IpAddr(std::net::IpAddr),
    #[cfg(feature = "fuzz-all-types")]
    SocketAddrV4(std::net::SocketAddrV4),
    #[cfg(feature = "fuzz-all-types")]
    SocketAddrV6(std::net::SocketAddrV6),
    #[cfg(feature = "fuzz-all-types")]
    SocketAddr(std::net::SocketAddr),

    // =========================================================================
    // NonZero types (facet-core/nonzero)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    NonZeroU8(std::num::NonZeroU8),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroU16(std::num::NonZeroU16),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroU32(std::num::NonZeroU32),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroU64(std::num::NonZeroU64),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroU128(std::num::NonZeroU128),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroUsize(std::num::NonZeroUsize),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroI8(std::num::NonZeroI8),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroI16(std::num::NonZeroI16),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroI32(std::num::NonZeroI32),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroI64(std::num::NonZeroI64),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroI128(std::num::NonZeroI128),
    #[cfg(feature = "fuzz-all-types")]
    NonZeroIsize(std::num::NonZeroIsize),

    // =========================================================================
    // Time types (std)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Duration(std::time::Duration),

    // =========================================================================
    // Path types (std + camino)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    PathBuf(std::path::PathBuf),
    #[cfg(feature = "fuzz-all-types")]
    Utf8PathBuf(camino::Utf8PathBuf),

    // =========================================================================
    // URL types (facet-core/url)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Url(url::Url),

    // =========================================================================
    // UUID/ULID types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Uuid(uuid::Uuid),
    #[cfg(feature = "fuzz-all-types")]
    Ulid(ulid::Ulid),

    // =========================================================================
    // Decimal/numeric types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Decimal(rust_decimal::Decimal),
    #[cfg(feature = "fuzz-all-types")]
    OrderedF32(ordered_float::OrderedFloat<f32>),
    #[cfg(feature = "fuzz-all-types")]
    OrderedF64(ordered_float::OrderedFloat<f64>),
    #[cfg(feature = "fuzz-all-types")]
    NotNanF32(ordered_float::NotNan<f32>),
    #[cfg(feature = "fuzz-all-types")]
    NotNanF64(ordered_float::NotNan<f64>),

    // =========================================================================
    // String types (smol_str, compact_str, smartstring, bytestring)
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    SmolStr(smol_str::SmolStr),
    #[cfg(feature = "fuzz-all-types")]
    CompactString(compact_str::CompactString),
    #[cfg(feature = "fuzz-all-types")]
    SmartString(smartstring::SmartString<smartstring::LazyCompact>),
    #[cfg(feature = "fuzz-all-types")]
    ByteString(bytestring::ByteString),

    // =========================================================================
    // Bytes types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    Bytes(bytes::Bytes),
    #[cfg(feature = "fuzz-all-types")]
    BytesMut(bytes::BytesMut),

    // =========================================================================
    // Chrono types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    ChronoDateTimeUtc(chrono::DateTime<chrono::Utc>),
    #[cfg(feature = "fuzz-all-types")]
    ChronoNaiveDateTime(chrono::NaiveDateTime),
    #[cfg(feature = "fuzz-all-types")]
    ChronoNaiveDate(chrono::NaiveDate),
    #[cfg(feature = "fuzz-all-types")]
    ChronoNaiveTime(chrono::NaiveTime),
    #[cfg(feature = "fuzz-all-types")]
    ChronoDuration(chrono::Duration),

    // =========================================================================
    // Time crate types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    TimeOffsetDateTime(time::OffsetDateTime),

    // =========================================================================
    // Jiff types
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    JiffTimestamp(jiff::Timestamp),
    #[cfg(feature = "fuzz-all-types")]
    JiffDate(jiff::civil::Date),
    #[cfg(feature = "fuzz-all-types")]
    JiffTime(jiff::civil::Time),
    #[cfg(feature = "fuzz-all-types")]
    JiffDateTime(jiff::civil::DateTime),

    // =========================================================================
    // Complex numbers
    // =========================================================================
    #[cfg(feature = "fuzz-all-types")]
    ComplexF32(num_complex::Complex<f32>),
    #[cfg(feature = "fuzz-all-types")]
    ComplexF64(num_complex::Complex<f64>),
}

impl FuzzValue {
    /// Get pointer and shape for this value.
    /// SAFETY: The returned pointer is only valid while `self` is alive.
    pub fn as_ptr_and_shape(&self) -> (*const (), &'static Shape) {
        match self {
            // Core scalars
            FuzzValue::Bool(v) => (v as *const _ as *const (), bool::SHAPE),
            FuzzValue::U8(v) => (v as *const _ as *const (), u8::SHAPE),
            FuzzValue::U16(v) => (v as *const _ as *const (), u16::SHAPE),
            FuzzValue::U32(v) => (v as *const _ as *const (), u32::SHAPE),
            FuzzValue::U64(v) => (v as *const _ as *const (), u64::SHAPE),
            FuzzValue::U128(v) => (v as *const _ as *const (), u128::SHAPE),
            FuzzValue::Usize(v) => (v as *const _ as *const (), usize::SHAPE),
            FuzzValue::I8(v) => (v as *const _ as *const (), i8::SHAPE),
            FuzzValue::I16(v) => (v as *const _ as *const (), i16::SHAPE),
            FuzzValue::I32(v) => (v as *const _ as *const (), i32::SHAPE),
            FuzzValue::I64(v) => (v as *const _ as *const (), i64::SHAPE),
            FuzzValue::I128(v) => (v as *const _ as *const (), i128::SHAPE),
            FuzzValue::Isize(v) => (v as *const _ as *const (), isize::SHAPE),
            FuzzValue::F32(v) => (v as *const _ as *const (), f32::SHAPE),
            FuzzValue::F64(v) => (v as *const _ as *const (), f64::SHAPE),
            FuzzValue::Char(v) => (v as *const _ as *const (), char::SHAPE),
            FuzzValue::String(v) => (v as *const _ as *const (), String::SHAPE),

            // Network types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Ipv4Addr(v) => (v as *const _ as *const (), std::net::Ipv4Addr::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Ipv6Addr(v) => (v as *const _ as *const (), std::net::Ipv6Addr::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::IpAddr(v) => (v as *const _ as *const (), std::net::IpAddr::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::SocketAddrV4(v) => {
                (v as *const _ as *const (), std::net::SocketAddrV4::SHAPE)
            }
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::SocketAddrV6(v) => {
                (v as *const _ as *const (), std::net::SocketAddrV6::SHAPE)
            }
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::SocketAddr(v) => (v as *const _ as *const (), std::net::SocketAddr::SHAPE),

            // NonZero types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroU8(v) => (v as *const _ as *const (), std::num::NonZeroU8::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroU16(v) => (v as *const _ as *const (), std::num::NonZeroU16::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroU32(v) => (v as *const _ as *const (), std::num::NonZeroU32::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroU64(v) => (v as *const _ as *const (), std::num::NonZeroU64::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroU128(v) => (v as *const _ as *const (), std::num::NonZeroU128::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroUsize(v) => {
                (v as *const _ as *const (), std::num::NonZeroUsize::SHAPE)
            }
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroI8(v) => (v as *const _ as *const (), std::num::NonZeroI8::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroI16(v) => (v as *const _ as *const (), std::num::NonZeroI16::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroI32(v) => (v as *const _ as *const (), std::num::NonZeroI32::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroI64(v) => (v as *const _ as *const (), std::num::NonZeroI64::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroI128(v) => (v as *const _ as *const (), std::num::NonZeroI128::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NonZeroIsize(v) => {
                (v as *const _ as *const (), std::num::NonZeroIsize::SHAPE)
            }

            // Time types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Duration(v) => (v as *const _ as *const (), std::time::Duration::SHAPE),

            // Path types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::PathBuf(v) => (v as *const _ as *const (), std::path::PathBuf::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Utf8PathBuf(v) => (v as *const _ as *const (), camino::Utf8PathBuf::SHAPE),

            // URL types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Url(v) => (v as *const _ as *const (), url::Url::SHAPE),

            // UUID/ULID
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Uuid(v) => (v as *const _ as *const (), uuid::Uuid::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Ulid(v) => (v as *const _ as *const (), ulid::Ulid::SHAPE),

            // Decimal/numeric
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Decimal(v) => (v as *const _ as *const (), rust_decimal::Decimal::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::OrderedF32(v) => (
                v as *const _ as *const (),
                ordered_float::OrderedFloat::<f32>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::OrderedF64(v) => (
                v as *const _ as *const (),
                ordered_float::OrderedFloat::<f64>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NotNanF32(v) => (
                v as *const _ as *const (),
                ordered_float::NotNan::<f32>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::NotNanF64(v) => (
                v as *const _ as *const (),
                ordered_float::NotNan::<f64>::SHAPE,
            ),

            // String types
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::SmolStr(v) => (v as *const _ as *const (), smol_str::SmolStr::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::CompactString(v) => (
                v as *const _ as *const (),
                compact_str::CompactString::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::SmartString(v) => (
                v as *const _ as *const (),
                smartstring::SmartString::<smartstring::LazyCompact>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ByteString(v) => (v as *const _ as *const (), bytestring::ByteString::SHAPE),

            // Bytes
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::Bytes(v) => (v as *const _ as *const (), bytes::Bytes::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::BytesMut(v) => (v as *const _ as *const (), bytes::BytesMut::SHAPE),

            // Chrono
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ChronoDateTimeUtc(v) => (
                v as *const _ as *const (),
                chrono::DateTime::<chrono::Utc>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ChronoNaiveDateTime(v) => {
                (v as *const _ as *const (), chrono::NaiveDateTime::SHAPE)
            }
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ChronoNaiveDate(v) => (v as *const _ as *const (), chrono::NaiveDate::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ChronoNaiveTime(v) => (v as *const _ as *const (), chrono::NaiveTime::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ChronoDuration(v) => (v as *const _ as *const (), chrono::Duration::SHAPE),

            // Time crate
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::TimeOffsetDateTime(v) => {
                (v as *const _ as *const (), time::OffsetDateTime::SHAPE)
            }

            // Jiff
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::JiffTimestamp(v) => (v as *const _ as *const (), jiff::Timestamp::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::JiffDate(v) => (v as *const _ as *const (), jiff::civil::Date::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::JiffTime(v) => (v as *const _ as *const (), jiff::civil::Time::SHAPE),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::JiffDateTime(v) => {
                (v as *const _ as *const (), jiff::civil::DateTime::SHAPE)
            }

            // Complex numbers
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ComplexF32(v) => (
                v as *const _ as *const (),
                num_complex::Complex::<f32>::SHAPE,
            ),
            #[cfg(feature = "fuzz-all-types")]
            FuzzValue::ComplexF64(v) => (
                v as *const _ as *const (),
                num_complex::Complex::<f64>::SHAPE,
            ),
        }
    }
}

// =============================================================================
// Fuzz Operation - like PartialOp but with owned values
// =============================================================================

/// An operation for fuzzing - like PartialOp but with owned FuzzValue instead of raw pointers.
#[derive(Debug, Clone)]
pub enum FuzzOp {
    // -------------------------------------------------------------------------
    // Scalars
    // -------------------------------------------------------------------------
    /// Set the current value
    Set(FuzzValue),

    // -------------------------------------------------------------------------
    // Structs
    // -------------------------------------------------------------------------
    /// Begin a struct field by name
    BeginField(String),

    /// Begin a struct field by index
    BeginNthField(usize),

    // -------------------------------------------------------------------------
    // Enums
    // -------------------------------------------------------------------------
    /// Select an enum variant by name
    SelectVariant(String),

    /// Select an enum variant by index
    SelectNthVariant(usize),

    // -------------------------------------------------------------------------
    // Options
    // -------------------------------------------------------------------------
    /// Begin the Some variant of an Option
    BeginSome,

    /// Set an Option to None
    SetNone,

    // -------------------------------------------------------------------------
    // Results
    // -------------------------------------------------------------------------
    /// Begin the Ok variant
    BeginOk,

    /// Begin the Err variant
    BeginErr,

    // -------------------------------------------------------------------------
    // Lists (Vec, etc.)
    // -------------------------------------------------------------------------
    /// Initialize a list
    InitList,

    /// Begin a list item
    BeginListItem,

    // -------------------------------------------------------------------------
    // Arrays
    // -------------------------------------------------------------------------
    /// Initialize an array
    InitArray,

    // -------------------------------------------------------------------------
    // Maps (HashMap, etc.)
    // -------------------------------------------------------------------------
    /// Initialize a map
    InitMap,

    /// Begin a map key
    BeginKey,

    /// Begin a map value
    BeginValue,

    // -------------------------------------------------------------------------
    // Sets
    // -------------------------------------------------------------------------
    /// Initialize a set
    InitSet,

    /// Begin a set item
    BeginSetItem,

    // -------------------------------------------------------------------------
    // Smart pointers
    // -------------------------------------------------------------------------
    /// Begin smart pointer inner (Box, Arc, Rc)
    BeginSmartPtr,

    /// Begin transparent inner (newtype wrappers)
    BeginInner,

    // -------------------------------------------------------------------------
    // Navigation
    // -------------------------------------------------------------------------
    /// End the current frame, return to parent
    End,

    // -------------------------------------------------------------------------
    // Mode switches
    // -------------------------------------------------------------------------
    /// Enter deferred mode
    BeginDeferred,

    /// Exit deferred mode, validate everything
    FinishDeferred,

    // -------------------------------------------------------------------------
    // Special
    // -------------------------------------------------------------------------
    /// Set current field/value to default
    SetDefault,

    /// Set nth field to its default value
    SetNthFieldToDefault(usize),

    /// Parse from string (for FromStr types)
    ParseFromStr(String),
}

// =============================================================================
// Type corpus - all the types we want to fuzz
// =============================================================================

/// Target types for fuzzing, covering different Facet implementation patterns.
#[derive(Debug, Clone, Copy)]
pub enum FuzzTargetType {
    // -------------------------------------------------------------------------
    // Scalars (direct Set operations)
    // -------------------------------------------------------------------------
    ScalarBool,
    ScalarU8,
    ScalarU32,
    ScalarI64,
    ScalarF64,
    ScalarChar,
    ScalarString,

    // -------------------------------------------------------------------------
    // Network types
    // -------------------------------------------------------------------------
    #[cfg(feature = "fuzz-all-types")]
    NetIpv4,
    #[cfg(feature = "fuzz-all-types")]
    NetIpv6,
    #[cfg(feature = "fuzz-all-types")]
    NetSocketAddr,

    // -------------------------------------------------------------------------
    // Structs of varying complexity
    // -------------------------------------------------------------------------
    /// Empty struct (unit-like)
    StructEmpty,
    /// Single field
    StructSingleField,
    /// Few fields (3)
    StructFewFields,
    /// Many fields (16)
    StructManyFields,
    /// Deeply nested (4 levels)
    StructDeepNested,

    // -------------------------------------------------------------------------
    // Enums
    // -------------------------------------------------------------------------
    /// Unit variants only (C-style)
    EnumUnit,
    /// Tuple variants
    EnumTuple,
    /// Struct variants
    EnumStruct,
    /// Mixed variant types
    EnumMixed,

    // -------------------------------------------------------------------------
    // Collections
    // -------------------------------------------------------------------------
    /// Vec<T>
    CollectionVec,
    /// Vec<Vec<T>> (nested)
    CollectionVecNested,
    /// HashMap<K, V>
    CollectionHashMap,
    /// BTreeMap<K, V>
    CollectionBTreeMap,
    /// HashSet<T>
    CollectionHashSet,
    /// [T; N] array
    CollectionArray,

    // -------------------------------------------------------------------------
    // Options and Results
    // -------------------------------------------------------------------------
    /// Option<T>
    OptionSimple,
    /// Option<Option<T>>
    OptionNested,
    /// Result<T, E>
    ResultSimple,
    /// Struct with Option fields
    StructWithOptions,

    // -------------------------------------------------------------------------
    // Smart pointers
    // -------------------------------------------------------------------------
    /// Box<T>
    SmartBox,
    /// Arc<T>
    SmartArc,
    /// Box<[T]>
    SmartBoxSlice,

    // -------------------------------------------------------------------------
    // Flattened structs
    // -------------------------------------------------------------------------
    /// Struct with #[facet(flatten)]
    StructFlattened,
    /// Nested flattening
    StructFlattenedNested,

    // -------------------------------------------------------------------------
    // Complex real-world-ish types
    // -------------------------------------------------------------------------
    /// Struct with map of structs containing options
    ComplexMapOfStructs,
    /// Config-like type with many optional fields
    ComplexConfig,
}

// =============================================================================
// Conversion: FuzzOp -> PartialOp
// =============================================================================

use crate::api2::PartialOp;

impl FuzzOp {
    /// Convert to PartialOp, borrowing the FuzzValue if present.
    /// The returned PartialOp is only valid while `self` is alive.
    pub fn as_partial_op(&self) -> PartialOp<'_> {
        match self {
            // Scalars
            FuzzOp::Set(v) => {
                let (ptr, shape) = v.as_ptr_and_shape();
                PartialOp::Set { ptr, shape }
            }

            // Structs
            FuzzOp::BeginField(name) => PartialOp::BeginField { name },
            FuzzOp::BeginNthField(index) => PartialOp::BeginNthField { index: *index },

            // Enums
            FuzzOp::SelectVariant(name) => PartialOp::SelectVariant { name },
            FuzzOp::SelectNthVariant(index) => PartialOp::SelectNthVariant { index: *index },

            // Options
            FuzzOp::BeginSome => PartialOp::BeginSome,
            FuzzOp::SetNone => PartialOp::SetNone,

            // Results
            FuzzOp::BeginOk => PartialOp::BeginOk,
            FuzzOp::BeginErr => PartialOp::BeginErr,

            // Lists
            FuzzOp::InitList => PartialOp::InitList,
            FuzzOp::BeginListItem => PartialOp::BeginListItem,

            // Arrays
            FuzzOp::InitArray => PartialOp::InitArray,

            // Maps
            FuzzOp::InitMap => PartialOp::InitMap,
            FuzzOp::BeginKey => PartialOp::BeginKey,
            FuzzOp::BeginValue => PartialOp::BeginValue,

            // Sets
            FuzzOp::InitSet => PartialOp::InitSet,
            FuzzOp::BeginSetItem => PartialOp::BeginSetItem,

            // Smart pointers
            FuzzOp::BeginSmartPtr => PartialOp::BeginSmartPtr,
            FuzzOp::BeginInner => PartialOp::BeginInner,

            // Defaults
            FuzzOp::SetDefault => PartialOp::SetDefault,
            FuzzOp::SetNthFieldToDefault(index) => {
                PartialOp::SetNthFieldToDefault { index: *index }
            }

            // Parsing
            FuzzOp::ParseFromStr(s) => PartialOp::ParseFromStr { s },

            // Navigation
            FuzzOp::End => PartialOp::End,

            // Mode switches
            FuzzOp::BeginDeferred => PartialOp::BeginDeferred,
            FuzzOp::FinishDeferred => PartialOp::FinishDeferred,
        }
    }
}

/// Convert a slice of FuzzOps to PartialOps.
/// The FuzzOps must outlive the returned PartialOps.
pub fn fuzz_ops_to_partial_ops<'a>(fuzz_ops: &'a [FuzzOp]) -> Vec<PartialOp<'a>> {
    fuzz_ops.iter().map(|op| op.as_partial_op()).collect()
}

// =============================================================================
// Type Corpus - actual Rust types for fuzzing
// =============================================================================

use facet::Facet;
use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};
use std::sync::Arc;

// -----------------------------------------------------------------------------
// Structs of varying complexity
// -----------------------------------------------------------------------------

/// Empty struct (unit-like)
#[derive(Facet, Debug, Default)]
pub struct EmptyStruct;

/// Single field struct
#[derive(Facet, Debug, Default)]
pub struct SingleFieldStruct {
    pub value: i32,
}

/// Struct with few fields (3)
#[derive(Facet, Debug, Default)]
pub struct FewFieldsStruct {
    pub name: String,
    pub count: u32,
    pub enabled: bool,
}

/// Struct with many fields (16)
#[derive(Facet, Debug, Default)]
pub struct ManyFieldsStruct {
    pub field_00: u8,
    pub field_01: u16,
    pub field_02: u32,
    pub field_03: u64,
    pub field_04: i8,
    pub field_05: i16,
    pub field_06: i32,
    pub field_07: i64,
    pub field_08: f32,
    pub field_09: f64,
    pub field_10: bool,
    pub field_11: char,
    pub field_12: String,
    pub field_13: String,
    pub field_14: String,
    pub field_15: String,
}

/// Deeply nested struct (4 levels)
#[derive(Facet, Debug, Default)]
pub struct Level0 {
    pub name: String,
    pub level1: Option<Level1>,
}

#[derive(Facet, Debug, Default)]
pub struct Level1 {
    pub value: i32,
    pub level2: Option<Level2>,
}

#[derive(Facet, Debug, Default)]
pub struct Level2 {
    pub items: Vec<String>,
    pub level3: Option<Level3>,
}

#[derive(Facet, Debug, Default)]
pub struct Level3 {
    pub data: HashMap<String, i32>,
}

// -----------------------------------------------------------------------------
// Enums
// -----------------------------------------------------------------------------

/// Unit variants only (C-style enum)
#[derive(Facet, Debug, Default)]
#[repr(u8)]
pub enum UnitEnum {
    #[default]
    A,
    B,
    C,
    D,
}

/// Tuple variants
#[derive(Facet, Debug)]
pub enum TupleEnum {
    Single(i32),
    Pair(String, u32),
    Triple(bool, f64, String),
}

/// Struct variants
#[derive(Facet, Debug)]
pub enum StructEnum {
    Empty {},
    Named { x: i32, y: i32 },
    Complex { name: String, values: Vec<i32> },
}

/// Mixed variant types
#[derive(Facet, Debug)]
pub enum MixedEnum {
    Unit,
    Tuple(String),
    Struct { value: i32 },
}

// -----------------------------------------------------------------------------
// Collections
// -----------------------------------------------------------------------------

/// Vec wrapper for fuzzing
#[derive(Facet, Debug, Default)]
pub struct VecWrapper {
    pub items: Vec<i32>,
}

/// Nested Vec
#[derive(Facet, Debug, Default)]
pub struct NestedVecWrapper {
    pub matrix: Vec<Vec<i32>>,
}

/// HashMap wrapper
#[derive(Facet, Debug, Default)]
pub struct HashMapWrapper {
    pub map: HashMap<String, i32>,
}

/// BTreeMap wrapper
#[derive(Facet, Debug, Default)]
pub struct BTreeMapWrapper {
    pub map: BTreeMap<String, i32>,
}

/// HashSet wrapper
#[derive(Facet, Debug, Default)]
pub struct HashSetWrapper {
    pub set: HashSet<String>,
}

/// BTreeSet wrapper
#[derive(Facet, Debug, Default)]
pub struct BTreeSetWrapper {
    pub set: BTreeSet<i32>,
}

/// Array wrapper
#[derive(Facet, Debug, Default)]
pub struct ArrayWrapper {
    pub arr: [i32; 4],
}

// -----------------------------------------------------------------------------
// Options and Results
// -----------------------------------------------------------------------------

/// Simple Option
#[derive(Facet, Debug, Default)]
pub struct OptionWrapper {
    pub maybe: Option<String>,
}

/// Nested Option
#[derive(Facet, Debug, Default)]
pub struct NestedOptionWrapper {
    pub maybe_maybe: Option<Option<i32>>,
}

/// Simple Result
#[derive(Facet, Debug)]
pub struct ResultWrapper {
    pub result: Result<String, String>,
}

/// Struct with multiple Option fields
#[derive(Facet, Debug, Default)]
pub struct MultiOptionStruct {
    pub required: String,
    pub opt1: Option<String>,
    pub opt2: Option<i32>,
    pub opt3: Option<bool>,
    pub opt4: Option<Vec<String>>,
}

// -----------------------------------------------------------------------------
// Smart pointers
// -----------------------------------------------------------------------------

/// Box wrapper
#[derive(Facet, Debug)]
pub struct BoxWrapper {
    pub boxed: Box<i32>,
}

/// Arc wrapper
#[derive(Facet, Debug)]
pub struct ArcWrapper {
    pub shared: Arc<String>,
}

/// Box<[T]> wrapper
#[derive(Facet, Debug)]
pub struct BoxSliceWrapper {
    pub slice: Box<[i32]>,
}

/// Nested smart pointers
#[derive(Facet, Debug)]
pub struct NestedSmartPtrWrapper {
    pub boxed_arc: Box<Arc<String>>,
}

// -----------------------------------------------------------------------------
// Flattened structs
// -----------------------------------------------------------------------------

/// Inner struct to be flattened
#[derive(Facet, Debug, Default)]
pub struct FlattenedInner {
    pub id: Option<String>,
    pub class: Option<String>,
}

/// Struct with flattened field
#[derive(Facet, Debug, Default)]
pub struct FlattenedStruct {
    pub name: String,
    #[facet(flatten)]
    pub attrs: FlattenedInner,
}

/// Nested flattening
#[derive(Facet, Debug, Default)]
pub struct DoublyFlattenedInner {
    pub style: Option<String>,
}

#[derive(Facet, Debug, Default)]
pub struct FlattenedMiddle {
    pub title: Option<String>,
    #[facet(flatten)]
    pub extra: DoublyFlattenedInner,
}

#[derive(Facet, Debug, Default)]
pub struct NestedFlattenedStruct {
    pub name: String,
    #[facet(flatten)]
    pub middle: FlattenedMiddle,
}

// -----------------------------------------------------------------------------
// Complex real-world-ish types
// -----------------------------------------------------------------------------

/// Profile for map-of-structs test
#[derive(Facet, Debug, Default)]
pub struct Profile {
    pub name: String,
    pub age: Option<u32>,
    pub email: Option<String>,
}

/// Struct with map of structs containing options (the bug reproduction case!)
#[derive(Facet, Debug, Default)]
pub struct MapOfStructs {
    pub profiles: HashMap<String, Profile>,
}

/// Config-like type with many optional fields and nested structures
#[derive(Facet, Debug, Default)]
pub struct ConfigType {
    pub name: String,
    pub version: Option<String>,
    pub debug: Option<bool>,
    pub timeout_ms: Option<u64>,
    pub endpoints: Vec<String>,
    pub features: HashSet<String>,
    pub metadata: HashMap<String, String>,
    pub nested: Option<ConfigNested>,
}

#[derive(Facet, Debug, Default)]
pub struct ConfigNested {
    pub enabled: bool,
    pub options: Vec<String>,
    pub limits: HashMap<String, i64>,
}

// -----------------------------------------------------------------------------
// Tuple types
// -----------------------------------------------------------------------------

/// Tuple wrapper
#[derive(Facet, Debug, Default)]
pub struct TupleWrapper {
    pub pair: (i32, String),
}

/// Larger tuple
#[derive(Facet, Debug, Default)]
pub struct LargeTupleWrapper {
    pub tuple: (u8, u16, u32, u64, i8, i16, i32, i64),
}

// -----------------------------------------------------------------------------
// Special cases
// -----------------------------------------------------------------------------

/// Recursive type via Box
#[derive(Facet, Debug)]
pub struct RecursiveType {
    pub value: i32,
    pub next: Option<Box<RecursiveType>>,
}

/// Type with default values
#[derive(Facet, Debug)]
pub struct WithDefaults {
    #[facet(default)]
    pub with_default: String,
    pub required: i32,
    #[facet(default)]
    pub opt_with_default: Option<String>,
}

fn main() {
    afl::fuzz!(|data: &[u8]| {
        // TODO: deserialize data into (FuzzTargetType, Vec<FuzzOp>)
        // and run the fuzzing logic
        let _ = data;
    });
}
