# facet-xml

XML serialization and deserialization for Rust using the facet reflection framework.

## Child Elements

By default, struct and field names are converted to `lowerCamelCase` and matched against child elements.

```xml
<person>
    <name>Ella</name>
    <age>42</age>
</person>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Person {
    name: String, // captures "Ella"
    age: u32,     // captures 42
}
# let xml_str = "<person><name>Ella</name><age>42</age></person>";
# let person: Person = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(person.name, "Ella");
# assert_eq!(person.age, 42);
```

## Attributes

Use `xml::attribute` to capture XML attributes:

```xml
<link href="/home">Home</link>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Link {
    #[facet(xml::attribute)]
    href: String,      // captures "/home"
    
    #[facet(xml::text)]
    text: String,      // captures "Home"
}
# let xml_str = r#"<link href="/home">Home</link>"#;
# let link: Link = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(link.href, "/home");
# assert_eq!(link.text, "Home");
```

## Text

Use `xml::text` to capture text content:

```xml
<name>Ella</name>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Name {
    #[facet(xml::text)]
    value: String, // captures "Ella"
}
# let xml_str = "<name>Ella</name>";
# let name: Name = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(name.value, "Ella");
```

## Lists

For list types (`Vec`, etc.), facet-xml collects items. By default, items are child elements with the **singularized** field name (via `facet-singularize`).

### Default: child elements with singularized name

```xml
<playlist>
    <track>Song A</track>
    <track>Song B</track>
</playlist>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Playlist {
    tracks: Vec<String>, // "tracks" â†’ expects <track> elements
}
# let xml_str = "<playlist><track>Song A</track><track>Song B</track></playlist>";
# let playlist: Playlist = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(playlist.tracks, vec!["Song A", "Song B"]);
```

### Override element name with `rename`

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Playlist {
    #[facet(rename = "song")]
    tracks: Vec<String>, // expects <song> instead of <track>
}
# let xml_str = "<playlist><song>Song A</song><song>Song B</song></playlist>";
# let playlist: Playlist = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(playlist.tracks, vec!["Song A", "Song B"]);
```

### Explicit `xml::elements` (same as default)

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Playlist {
    #[facet(xml::elements)]
    tracks: Vec<String>,
}
# let xml_str = "<playlist><track>Song A</track><track>Song B</track></playlist>";
# let playlist: Playlist = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(playlist.tracks, vec!["Song A", "Song B"]);
```

### Collect text nodes with `xml::text`

```xml
<message>Hello <b>world</b>!</message>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
struct Message {
    #[facet(xml::text)]
    parts: Vec<String>, // collects text nodes: ["Hello ", "!"]
}
# let xml_str = "<message>Hello world!</message>";
# let msg: Message = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(msg.parts, vec!["Hello world!"]);
```

### Collect attributes with `xml::attribute`

```xml
<element foo="1" bar="2" baz="3"/>
```

```rust
# use facet::Facet;
# use facet_xml as xml;
#[derive(Facet, Debug)]
#[facet(rename = "element")]
struct Element {
    #[facet(xml::attribute)]
    values: Vec<String>, // collects all attribute values
}
# let xml_str = r#"<element foo="1" bar="2" baz="3"/>"#;
# let elem: Element = facet_xml::from_str(xml_str).unwrap();
# assert_eq!(elem.values, vec!["1", "2", "3"]);
```
