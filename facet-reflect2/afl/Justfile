# Build and run the fuzzer with SAND (decoupled sanitizers)
fuzz: build
    cargo afl fuzz -i in -o out \
        -w target/debug/facet-reflect2-afl-asan \
        -w target/debug/facet-reflect2-afl-msan \
        -- target/debug/facet-reflect2-afl

# Build all binaries: native + sanitizer variants
build: build-native build-asan build-msan

# Build native binary (no sanitizers, full speed)
build-native:
    cargo afl build

# Build with AddressSanitizer + UBSan
build-asan:
    AFL_LLVM_ONLY_FSRV=1 AFL_USE_ASAN=1 AFL_USE_UBSAN=1 cargo afl build
    cp target/debug/facet-reflect2-afl target/debug/facet-reflect2-afl-asan

# Build with MemorySanitizer
build-msan:
    AFL_LLVM_ONLY_FSRV=1 AFL_USE_MSAN=1 cargo afl build
    cp target/debug/facet-reflect2-afl target/debug/facet-reflect2-afl-msan

# Resume fuzzing from previous state
resume: build
    cargo afl fuzz -i- -o out \
        -w target/debug/facet-reflect2-afl-asan \
        -w target/debug/facet-reflect2-afl-msan \
        -- target/debug/facet-reflect2-afl

# Run a single input file
run file:
    target/debug/facet-reflect2-afl < {{ file }}

# Run with backtrace
run-bt file:
    RUST_BACKTRACE=1 target/debug/facet-reflect2-afl < {{ file }}

# Minimize a crash input
minimize file:
    cargo afl tmin -i {{ file }} -o minimized.bin -- target/debug/facet-reflect2-afl
    @echo "Minimized input saved to minimized.bin"

# List all crashes
crashes:
    @ls -la out/default/crashes/ 2>/dev/null || echo "No crashes yet"

# Reproduce all crashes and show unique panic messages
reproduce-all:
    @for f in out/default/crashes/id:*; do \
        target/debug/facet-reflect2-afl < "$$f" 2>&1 | grep -E "^thread.*panicked" || true; \
    done | sort -u

# Show AFL edge coverage from the corpus
edges: build-native
    cargo afl showmap -C -i out/default/queue -o /dev/stdout -- target/debug/facet-reflect2-afl

# Build with LLVM source coverage (non-AFL binary)
build-cov:
    CARGO_INCREMENTAL=0 RUSTFLAGS="-C instrument-coverage" cargo build --features cov

# Generate source coverage report from corpus
# Usage: just cov [format]

# Formats: report (default), html
cov format="report": build-cov
    #!/usr/bin/env -S bash -euo pipefail
    rm -f *.profraw default.profdata
    files=(out/default/queue/*)
    total=${#files[@]}
    i=0
    for f in "${files[@]}"; do
        i=$((i + 1))
        printf "\r%d/%d" "$i" "$total"
        target/debug/facet-reflect2-afl < "$f" 2>/dev/null || true
    done
    echo
    llvm-profdata merge -sparse *.profraw -o default.profdata
    if [ "{{ format }}" = "html" ]; then
        llvm-cov show target/debug/facet-reflect2-afl \
            --instr-profile=default.profdata \
            --ignore-filename-regex='/.cargo/|/rustc/|afl/src' \
            --format=html --output-dir=coverage
        echo "Coverage report written to coverage/"
        open coverage/index.html 2>/dev/null || true
    else
        llvm-cov report target/debug/facet-reflect2-afl \
            --instr-profile=default.profdata \
            --ignore-filename-regex='/.cargo/|/rustc/|afl/src'
    fi
    rm -f *.profraw default.profdata

# Clean build artifacts and output
clean:
    rm -rf target out minimized.bin
