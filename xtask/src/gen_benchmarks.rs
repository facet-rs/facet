//! Generate benchmark code from benchmarks.kdl definitions.
//!
//! This ensures every benchmark has BOTH divan (wall-clock) AND gungraun (instruction count) versions
//! for ALL 5 targets (facet_format_jit, facet_format_json, facet_json, facet_json_cranelift, serde_json).

use facet::Facet;
use facet_kdl as kdl; // Make kdl:: paths work in attributes
use std::fs;
use std::path::Path;

#[derive(Debug, Facet)]
struct BenchmarkFile {
    #[facet(kdl::children, default)]
    benchmarks: Vec<BenchmarkDef>,
    #[facet(kdl::children, default)]
    type_defs: Vec<TypeDef>,
}

#[derive(Debug, Facet, Clone)]
struct BenchmarkDef {
    #[facet(kdl::property)]
    name: String,
    #[facet(kdl::property, rename = "type")]
    type_name: String,
    #[facet(kdl::property)]
    category: String,
    #[facet(kdl::child)]
    json: JsonData,
}

#[derive(Debug, Facet, Clone)]
struct JsonData {
    #[facet(kdl::argument)]
    content: String,
}

#[derive(Debug, Facet, Clone)]
struct TypeDef {
    #[facet(kdl::property)]
    name: String,
    #[facet(kdl::child)]
    code: CodeBlock,
}

#[derive(Debug, Facet, Clone)]
struct CodeBlock {
    #[facet(kdl::argument)]
    content: String,
}

pub fn generate_benchmarks(
    kdl_path: &Path,
    output_path: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    println!(
        "ðŸ“– Reading benchmark definitions from {}",
        kdl_path.display()
    );

    let kdl_content = fs::read_to_string(kdl_path)?;
    let file: BenchmarkFile = match facet_kdl::from_str(&kdl_content) {
        Ok(f) => f,
        Err(e) => {
            eprintln!("âŒ Failed to parse KDL:");
            eprintln!("{:?}", e);
            return Err(e.into());
        }
    };

    let benchmarks = file.benchmarks;
    let type_defs = file.type_defs;

    println!("   Found {} benchmarks", benchmarks.len());
    println!("   Found {} type definitions", type_defs.len());

    let mut output = String::new();

    // File header
    output.push_str("//! AUTO-GENERATED by cargo xtask gen-benchmarks\n");
    output.push_str("//! DO NOT EDIT - Edit facet-json/benches/benchmarks.kdl instead\n");
    output.push_str("//!\n");
    output.push_str(
        "//! This file ensures parity: every benchmark has BOTH divan AND gungraun versions\n",
    );
    output.push_str("//! for ALL 5 targets.\n\n");

    // Imports
    output.push_str("use facet::Facet;\n");
    output.push_str("use facet_format::jit as format_jit;\n");
    output.push_str("use facet_format_json::JsonParser;\n");
    output.push_str("use divan::Bencher;\n");
    output.push_str("use std::hint::black_box;\n\n");

    // Type definitions
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Type Definitions\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    for type_def in &type_defs {
        output.push_str(&type_def.code.content);
        output.push_str("\n\n");
    }

    // Generate benchmarks
    for bench_def in &benchmarks {
        output.push_str(&generate_benchmark_module(bench_def)?);
    }

    // Generate gungraun groups
    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str("// Gungraun Benchmark Groups\n");
    output.push_str(
        "// ============================================================================\n\n",
    );

    // Re-export gungraun benchmarks at module level for macro compatibility
    output.push_str("// Re-export gungraun benchmarks (macro doesn't support :: paths)\n");
    for bench_def in &benchmarks {
        output.push_str(&format!(
            "use {}::gungraun_{}_facet_format_jit as gungraun_{}_facet_format_jit;\n",
            bench_def.name, bench_def.name, bench_def.name
        ));
        for target in &["facet_format_json", "facet_json", "serde_json"] {
            output.push_str(&format!(
                "use {}::gungraun_{}_{}_deserialize as gungraun_{}_{};\n",
                bench_def.name, bench_def.name, target, bench_def.name, target
            ));
        }
        output.push_str(&format!(
            "#[cfg(feature = \"cranelift\")]\nuse {}::gungraun_{}_facet_json_cranelift as gungraun_{}_facet_json_cranelift;\n",
            bench_def.name, bench_def.name, bench_def.name
        ));
    }
    output.push('\n');

    for bench_def in &benchmarks {
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_benchmarks;\n    benchmarks =\n",
            bench_def.name
        ));

        for target in &[
            "facet_format_jit",
            "facet_format_json",
            "facet_json",
            "serde_json",
        ] {
            output.push_str(&format!(
                "        gungraun_{}_{},\n",
                bench_def.name, target
            ));
        }

        output.push_str(");\n\n");

        // Cranelift group
        output.push_str("#[cfg(feature = \"cranelift\")]\n");
        output.push_str(&format!(
            "gungraun::library_benchmark_group!(\n    name = {}_cranelift;\n    benchmarks = gungraun_{}_facet_json_cranelift\n);\n\n",
            bench_def.name, bench_def.name
        ));
    }

    // Main gungraun entry point
    output.push_str("// Gungraun main\n");
    output.push_str("#[cfg(not(feature = \"cranelift\"))]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!("        {}_benchmarks", bench_def.name));
    }
    output.push_str("\n);\n\n");

    output.push_str("#[cfg(feature = \"cranelift\")]\n");
    output.push_str("gungraun::main!(\n    library_benchmark_groups =\n");
    for (i, bench_def) in benchmarks.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }
        output.push_str(&format!(
            "        {}_benchmarks,\n        {}_cranelift",
            bench_def.name, bench_def.name
        ));
    }
    output.push_str("\n);\n");

    // Write output
    println!("âœï¸  Writing generated code to {}", output_path.display());
    fs::write(output_path, output)?;

    println!(
        "âœ… Generated {} benchmarks Ã— 5 targets Ã— 2 harnesses = {} total benchmark functions!",
        benchmarks.len(),
        benchmarks.len() * 5 * 2
    );

    Ok(())
}

fn generate_benchmark_module(
    bench_def: &BenchmarkDef,
) -> Result<String, Box<dyn std::error::Error>> {
    let mut output = String::new();

    output.push_str(
        "// ============================================================================\n",
    );
    output.push_str(&format!("// BENCHMARK: {}\n", bench_def.name));
    output.push_str(
        "// ============================================================================\n\n",
    );

    output.push_str(&format!("mod {} {{\n", bench_def.name));
    output.push_str("    use super::*;\n\n");

    // JSON data
    output.push_str(&format!(
        "    static JSON: &[u8] = br#\"{}\"#;\n\n",
        bench_def.json.content
    ));

    // Divan benchmarks
    output.push_str("    // ===== DIVAN (wall-clock) =====\n\n");

    let targets = vec![
        (
            "facet_format_jit",
            "format_jit::deserialize_with_fallback",
            "JsonParser::new",
            true,
        ),
        (
            "facet_format_json",
            "facet_format_json::from_slice",
            "",
            false,
        ),
        ("facet_json", "facet_json::from_slice", "", false),
        (
            "facet_json_cranelift",
            "facet_json::cranelift::from_str_with_fallback",
            "",
            false,
        ),
        ("serde_json", "serde_json::from_slice", "", false),
    ];

    for (target_name, deserialize_fn, wrapper, needs_parser) in &targets {
        let is_cranelift = target_name.contains("cranelift");
        let is_str = is_cranelift; // cranelift uses &str not &[u8]

        if is_cranelift {
            output.push_str("    #[cfg(feature = \"cranelift\")]\n");
        }

        output.push_str("    #[divan::bench]\n");
        output.push_str(&format!(
            "    fn {}_deserialize(bencher: Bencher) {{\n",
            target_name
        ));

        if is_str {
            output.push_str(
                "        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n",
            );
        }

        output.push_str("        bencher.bench(|| {\n");

        if *needs_parser {
            output.push_str(&format!(
                "            black_box({}::<{}, _>({}(black_box(JSON))).unwrap())\n",
                deserialize_fn, bench_def.type_name, wrapper
            ));
        } else if is_str {
            output.push_str(&format!(
                "            black_box({}::<{}>(black_box(json_str)).unwrap())\n",
                deserialize_fn, bench_def.type_name
            ));
        } else {
            output.push_str(&format!(
                "            black_box({}::<{}>(black_box(JSON)).unwrap())\n",
                deserialize_fn, bench_def.type_name
            ));
        }

        output.push_str("        });\n");
        output.push_str("    }\n\n");
    }

    // Gungraun benchmarks
    output.push_str("    // ===== GUNGRAUN (instruction counts) =====\n\n");

    // JIT warmup
    output.push_str("    fn setup_jit() -> &'static [u8] {\n");
    output.push_str(&format!(
        "        let _ = format_jit::deserialize_with_fallback::<{}, _>(JsonParser::new(JSON));\n",
        bench_def.type_name
    ));
    output.push_str("        JSON\n");
    output.push_str("    }\n\n");

    // Gungraun benchmarks - use unique names including benchmark name
    output.push_str("    #[gungraun::library_benchmark]\n");
    output.push_str("    #[bench::cached(setup = setup_jit)]\n");
    output.push_str(&format!(
        "    fn gungraun_{}_facet_format_jit(json: &[u8]) -> ",
        bench_def.name
    ));
    output.push_str(&bench_def.type_name);
    output.push_str(" {\n");
    output.push_str("        let parser = JsonParser::new(black_box(json));\n");
    output.push_str(&format!(
        "        black_box(format_jit::deserialize_with_fallback::<{}, _>(parser).unwrap())\n",
        bench_def.type_name
    ));
    output.push_str("    }\n\n");

    // Other gungraun targets (no warmup needed)
    for target in &["facet_format_json", "facet_json", "serde_json"] {
        output.push_str("    #[gungraun::library_benchmark]\n");
        output.push_str(&format!(
            "    fn gungraun_{}_{}_deserialize() -> {} {{\n",
            bench_def.name, target, bench_def.type_name
        ));
        output.push_str(&format!(
            "        black_box({}::from_slice::<{}>(black_box(JSON)).unwrap())\n",
            target, bench_def.type_name
        ));
        output.push_str("    }\n\n");
    }

    // Cranelift gungraun with warmup
    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    fn setup_cranelift() -> &'static str {\n");
    output.push_str("        let json_str = unsafe { std::str::from_utf8_unchecked(JSON) };\n");
    output.push_str(&format!(
        "        let _ = facet_json::cranelift::from_str_with_fallback::<{}>(json_str);\n",
        bench_def.type_name
    ));
    output.push_str("        json_str\n");
    output.push_str("    }\n\n");

    output.push_str("    #[cfg(feature = \"cranelift\")]\n");
    output.push_str("    #[gungraun::library_benchmark]\n");
    output.push_str("    #[bench::cached(setup = setup_cranelift)]\n");
    output.push_str(&format!(
        "    fn gungraun_{}_facet_json_cranelift(json: &str) -> {} {{\n",
        bench_def.name, bench_def.type_name
    ));
    output.push_str(&format!(
        "        black_box(facet_json::cranelift::from_str_with_fallback::<{}>(black_box(json)).unwrap())\n",
        bench_def.type_name
    ));
    output.push_str("    }\n");

    output.push_str("}\n\n");

    Ok(output)
}
