// Benchmark definitions for code generator
// Each benchmark automatically gets divan + gungraun versions for all 5 targets

benchmark name="simple_struct" type="SimpleRecord" category="micro" {
    json "{\"id\": 42, \"name\": \"test\", \"active\": true}"
}

benchmark name="single_nested_struct" type="Outer" category="micro" {
    json "{\"id\": 42, \"inner\": {\"x\": 10, \"y\": 20}, \"name\": \"test\"}"
}

benchmark name="simple_with_options" type="WithOptions" category="micro" {
    json "{\"id\": 42, \"maybe_count\": 123, \"maybe_flag\": null, \"maybe_value\": 2.5}"
}

// Type definitions
type_def name="SimpleRecord" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct SimpleRecord {
    id: u64,
    name: String,
    active: bool,
}
"""
}

type_def name="Inner" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct Inner {
    x: i64,
    y: i64,
}
"""
}

type_def name="Outer" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct Outer {
    id: u64,
    inner: Inner,
    name: String,
}
"""
}

type_def name="WithOptions" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct WithOptions {
    id: u64,
    maybe_count: Option<i64>,
    maybe_flag: Option<bool>,
    maybe_value: Option<f64>,
}
"""
}

// ============================================================================
// Array Benchmarks (Vec<T>)
// ============================================================================

benchmark name="booleans" type="Vec<bool>" category="array" {
    json_file "data/booleans.json"
}

benchmark name="integers" type="Vec<u64>" category="array" {
    json_file "data/integers.json"
}

benchmark name="floats" type="Vec<f64>" category="array" {
    json_file "data/floats.json"
}

benchmark name="short_strings" type="Vec<String>" category="array" {
    json_file "data/short_strings.json"
}

benchmark name="long_strings" type="Vec<String>" category="array" {
    json_file "data/long_strings.json"
}

benchmark name="escaped_strings" type="Vec<String>" category="array" {
    json_file "data/escaped_strings.json"
}

// ============================================================================
// Complex Benchmarks
// ============================================================================

benchmark name="hashmaps" type="std::collections::HashMap<String, u64>" category="complex" {
    json_file "data/hashmaps.json"
}

benchmark name="nested_structs" type="Vec<NestedOuter>" category="complex" {
    json_file "data/nested_structs.json"
}

benchmark name="options" type="Vec<OptionsMaybeData>" category="complex" {
    json_file "data/options.json"
}

type_def name="NestedOuter" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct NestedOuter {
    id: u64,
    inner: NestedInner,
}
"""
}

type_def name="NestedInner" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct NestedInner {
    name: String,
    value: f64,
    deep: NestedDeep,
}
"""
}

type_def name="NestedDeep" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct NestedDeep {
    flag: bool,
    count: u32,
}
"""
}

type_def name="OptionsMaybeData" {
    code """
#[derive(Debug, PartialEq, Facet, serde::Serialize, serde::Deserialize, Clone)]
struct OptionsMaybeData {
    required: u64,
    optional_string: Option<String>,
    optional_number: Option<f64>,
}
"""
}

// ============================================================================
// Realistic Benchmarks (Large Real-World Data)
// ============================================================================



// Note: flatten benchmarks (flatten_2enums, flatten_4enums) have complex
// flattened enum types that need special handling. To be added in follow-up.
