+++
title = "Extension Attributes Diagnostics (RFC)"
+++

**Status:** This is an RFC (Request for Comments) describing a planned feature. It is not yet implemented.

This document describes a technique for providing helpful compile-time error messages when users mistype extension attribute names like `#[facet(kdl::nonexistent)]`.

## The Problem

When a user writes an unknown attribute:

```rust
#[derive(Facet)]
struct Config {
    #[facet(kdl::chld)]  // typo: should be "child"
    items: Vec<Item>,
}
```

Currently, this compiles successfully. The attribute is stored as an `ExtensionAttr { ns: "kdl", key: "chld", ... }`. At runtime, when `facet-kdl` checks `field.has_extension_attr("kdl", "child")`, it doesn't match because the key is `"chld"`, not `"child"`. The field is silently treated as a regular field instead of a KDL child.

The user might eventually get a confusing runtime error, or worse, silent misbehavior. Even if compilation does fail (e.g., because `facet-kdl` requires certain attributes), the error message is unhelpful:

```
error[E0277]: the trait bound `Config: SomeKdlTrait` is not satisfied
  --> src/lib.rs:3:10
   |
3  | #[derive(Facet)]
   |          ^^^^^ the trait `SomeKdlTrait` is not implemented for `Config`
   |
   = help: the following implementations were found:
             <Config as OtherTrait>
```

This doesn't tell the user *why* it failed or that they have a typo in their attribute.

## The Solution

We use a combination of:
1. **Fallback type definitions** at the call site (with user's span)
2. **Glob imports** that shadow the fallback when valid attributes exist
3. **`#[diagnostic::on_unimplemented]`** to provide clear error messages

### How It Works

The derive macro generates code like this:

```rust
// Generated by #[derive(Facet)] for #[facet(kdl::chld)]
{
    // Fallback type - defined OUTSIDE the inner scope
    // This uses the span from the user's attribute tokens!
    struct chld;

    {
        // Glob import from the namespace's attrs module
        // This NEVER fails, even if the module is empty
        use facet_kdl::attrs::*;

        // If `chld` existed in facet_kdl::attrs, it would shadow
        // the outer fallback. But it doesn't, so `chld` resolves
        // to our fallback struct.

        // This trait bound check triggers the diagnostic
        fn __check_attr<A>() where facet_kdl::KdlNamespace: facet_kdl::HasKdlAttr<A> {}
        __check_attr::<chld>();
    }

    // ... rest of ExtensionAttr emission ...
}
```

The key insight: **glob imports silently succeed even when nothing matches**, but if a matching name exists, it shadows the outer definition.

### The Error Message

When `chld` is not a valid KDL attribute, the compiler produces:

```
error[E0277]: `chld` is not a recognized KDL attribute
  --> src/lib.rs:4:18
   |
4  |     #[facet(kdl::chld)]
   |                  ^^^^ unknown attribute
   |
   = help: valid attributes are: `child`, `children`, `argument`, `property`
```

The error points directly at the user's typo because the fallback `struct chld;` was created with the span from their tokens.

## Crate-Side Implementation

Extension crates need to define their attributes using the provided macro. Here's how `facet-kdl` would do it:

### Using the Helper Macro

```rust
// In facet-kdl/src/lib.rs

facet::define_extension_attrs! {
    /// The KDL namespace for extension attributes
    namespace KdlNamespace;

    /// Trait for validating KDL attributes
    trait HasKdlAttr;

    /// Module containing attribute marker types
    mod attrs;

    /// Valid attributes in this namespace
    attributes {
        /// Marks a field as a KDL child node
        child,
        /// Marks a field as containing KDL children
        children,
        /// Marks a field as a KDL argument (positional value)
        argument,
        /// Marks a field as a KDL property (key=value)
        property,
    }
}
```

### What the Macro Expands To

The `define_extension_attrs!` macro generates:

```rust
/// The KDL namespace for extension attributes
pub struct KdlNamespace;

/// Module containing attribute marker types
pub mod attrs {
    /// Marks a field as a KDL child node
    pub struct child;
    /// Marks a field as containing KDL children
    pub struct children;
    /// Marks a field as a KDL argument (positional value)
    pub struct argument;
    /// Marks a field as a KDL property (key=value)
    pub struct property;
}

/// Trait for validating KDL attributes
#[diagnostic::on_unimplemented(
    message = "`{A}` is not a recognized KDL attribute",
    label = "unknown attribute",
    note = "valid attributes are: `child`, `children`, `argument`, `property`"
)]
pub trait HasKdlAttr<A> {}

// Implement the trait for each valid attribute
impl HasKdlAttr<attrs::child> for KdlNamespace {}
impl HasKdlAttr<attrs::children> for KdlNamespace {}
impl HasKdlAttr<attrs::argument> for KdlNamespace {}
impl HasKdlAttr<attrs::property> for KdlNamespace {}
```

Note that the `note = "valid attributes are: ..."` string is generated by `define_extension_attrs!` which runs *inside* `facet-kdl`. This macro knows the full list of attributes because they're declared right there in its input. The `#[derive(Facet)]` macro in `facet-macros` doesn't need to know the list - it just emits code that references `facet_kdl::HasKdlAttr<T>`, and the trait's `on_unimplemented` attribute (defined in `facet-kdl`) provides the helpful message.

## The Derive Macro Side

The `facet-macros-emit` crate needs to generate the validation code. For each extension attribute `#[facet(ns::key)]`:

```rust
// In facet-macros-emit/src/extension.rs

pub fn emit_extension_attr_with_validation(
    ns: &Ident,      // e.g., "kdl"
    key: &Ident,     // e.g., "child" - preserves span!
    args: &TokenStream,
) -> TokenStream {
    let args_tokens = emit_token_trees(args);
    let ns_str = ns.to_string();
    let key_str = key.to_string();

    // The namespace module path (e.g., facet_kdl)
    // This needs to be configurable or follow a convention
    let ns_module = format_ident!("facet_{}", ns);

    quote! {
        {
            // Fallback type with user's span - defined in outer scope
            struct #key;

            {
                // Glob import shadows the fallback if the attr exists
                use #ns_module::attrs::*;

                // Trait bound check - triggers on_unimplemented if invalid
                fn __facet_check_attr<__A>()
                where
                    #ns_module::KdlNamespace: #ns_module::HasKdlAttr<__A>
                {}
                __facet_check_attr::<#key>();
            }

            // The actual ExtensionAttr value
            fn __ext_get() -> &'static (dyn ::core::any::Any + ::core::marker::Send + ::core::marker::Sync) {
                static __UNIT: () = ();
                &__UNIT
            }

            ::facet::ExtensionAttr {
                ns: #ns_str,
                key: #key_str,
                args: &[#args_tokens],
                get: __ext_get,
            }
        }
    }
}
```

## Namespace Resolution

The derive macro needs to know how to map namespace identifiers (like `kdl`) to crate paths (like `facet_kdl`). Options:

1. **Convention-based**: `kdl` â†’ `facet_kdl` (simple, predictable)
2. **Registry**: A central registry in `facet-core` that maps namespaces
3. **Attribute-based**: Users declare the mapping via `#[facet(use_namespace(kdl = "facet_kdl"))]`

For now, we use the convention-based approach: namespace `foo` maps to crate `facet_foo`.

## Why Not Validate Namespaces Too?

We considered using the same trick for validating that a namespace exists, but this doesn't work as cleanly because:

1. We'd need to import from an unknown crate name
2. If the crate doesn't exist, `use unknown_crate::*;` fails loudly
3. There's no way to make a crate import "optional" at compile time

Namespace validation would require a different approach, perhaps using `cfg` attributes or build scripts.

## Testing

Add UI tests to verify the error messages:

```rust
// tests/compile_tests/unknown_kdl_attr.rs
use facet::Facet;

#[derive(Facet)]
struct Config {
    #[facet(kdl::nonexistent)]
    field: String,
}

fn main() {}
```

Expected error:
```
error[E0277]: `nonexistent` is not a recognized KDL attribute
  --> tests/compile_tests/unknown_kdl_attr.rs:6:18
   |
6  |     #[facet(kdl::nonexistent)]
   |                  ^^^^^^^^^^^ unknown attribute
```

## Summary

This technique provides:

- **Compile-time validation** of extension attribute names
- **Helpful error messages** pointing at the exact typo
- **Zero runtime cost** - all checks happen at compile time
- **Easy adoption** for extension crate authors via helper macro
